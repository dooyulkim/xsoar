category: Network Security
commonfields:
  id: Zscaler
  version: -1
configuration:
- display: Cloud Name (i.e., https://admin.zscalertwo.net)
  name: cloud
  required: true
  type: 0
- display: Credentials
  name: credentials
  required: true
  type: 9
- display: API Key
  name: key
  required: true
  type: 4
- additionalinfo: If enabled, the integration will log out after executing each command.
  defaultvalue: "true"
  display: Auto Logout
  name: auto_logout
  required: false
  type: 8
- additionalinfo: If enabled, the integration will activate the command changes after
    each execution. If disabled, use the 'zscaler-activate-changes' command to activate
    Zscaler command changes.
  defaultvalue: "true"
  display: Auto Activate Changes
  name: auto_activate
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: 1.0.6
    packID: Zscaler
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Zscaler is a cloud security solution built for performance and flexible
  scalability. This integration enables you to manage URL and IP address whitelists
  and blacklists, manage and update categories, get Sandbox reports, and manually
  log in, log out, and activate changes in a Zscaler session.
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/zscaler)'
display: Zscaler
image: data:image/png;base64,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
name: Zscaler
script:
  commands:
  - arguments:
    - default: true
      description: A comma-separated list of URLs to blacklist. For example, snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Adds the specified URLs to the blacklist.
    execution: true
    name: zscaler-blacklist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs for which to look up the classification.  For
        example, abc.com,xyz.com. The maximum number of URLs per call is 100. A URL
        cannot exceed 1024 characters. If there are multiple URLs, set the 'multiple'
        argument to 'true'.
      isArray: true
      name: url
    - auto: PREDEFINED
      default: true
      defaultValue: "true"
      description: Whether there are multiple URLs in the 'url' argument. If a URL
        contains commas, set this argument to 'false' and enter the single URL as
        the 'url' argument. Default is 'true'.
      name: multiple
      predefined:
      - "true"
      - "false"
    description: Looks up the classification for the each of the specified URLs.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL that was searched.
      type: string
    - contextPath: URL.Address
      description: The URL that was searched.
      type: string
    - contextPath: URL.urlClassifications
      description: The classification of the URL. For example, MUSIC or WEB_SEARCH.
      type: string
    - contextPath: URL.urlClassificationsWithSecurityAlert
      description: The classifications of the URLs that have security alerts.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that tagged the URL as malicious.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason the vendor tagged the URL as malicious.
      type: string
    - contextPath: DBotScore.Indicator
      description: The URL that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The URL type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor that calculated the DBot score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual DBot score.
      type: number
  - arguments:
    - default: true
      description: A comma-separated list of IP address for which to look up the classification.
        For example, 8.8.8.8,1.2.3.4. The maximum number of URLs per call is 100.
        An IP address cannot exceed 1024 characters.
      name: ip
      required: true
    description: Looks up the classification for each of the specified IP addresses.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address that was searched.
      type: string
    - contextPath: IP.ipClassifications
      description: The classification of the IP address. For example, MUSIC or WEB_SEARCH.
      type: string
    - contextPath: IP.iplClassificationsWithSecurityAlert
      description: Classifications that have a security alert for the IP address.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that tagged the IP address
        as malicious.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason the vendor tagged the IP
        address as malicious.
      type: string
    - contextPath: DBotScore.Indicator
      description: The IP address that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The IP address type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the DBot score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual DBot score.
      type: number
  - arguments:
    - default: true
      description: A comma-separated list of URLs to remove from the blacklist. For
        example, snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Removes the specified URLs from the blacklist.
    execution: true
    name: zscaler-undo-blacklist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs to add to the whitelist. For example,
        snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Adds the specified URLs to the whitelist.
    execution: true
    name: zscaler-whitelist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs to remove from the whitelist. For
        example, snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Removes the specified URLs from the whitelist.
    execution: true
    name: zscaler-undo-whitelist-url
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to remove from the whitelist.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Removes the specified IP addresses from the whitelist.
    execution: true
    name: zscaler-undo-whitelist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to add to the whitelist.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Adds the specified IP address to the whitelist.
    execution: true
    name: zscaler-whitelist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to remove from the blacklist.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Removes the specified IP addresses from the blacklist.
    name: zscaler-undo-blacklist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to add to the blacklist.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Adds the specified IP addresses to the blacklist.
    execution: true
    name: zscaler-blacklist-ip
  - arguments:
    - description: The ID of the category to add the specified URLs to. For example,
        RADIO_STATIONS. You can retrieve the category IDs by running the 'zscaler-get-categories'
        command.
      name: category-id
      required: true
    - description: A comma-separated list of URLs to add to the specified category.
        For example, pandora.com,spotify.com.
      isArray: true
      name: url
      required: true
    description: Adds URLs to the specified category.
    name: zscaler-category-add-url
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - description: The ID of the category to add the specified IP addresses to. For
        example, RADIO_STATIONS. You can retrieve the category IDs by running the
        'zscaler-get-categories' command.
      name: category-id
      required: true
    - description: A comma-separated list of IP address to add to the specified category.
        For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: ip
      required: true
    description: Adds IP address to the specified category.
    name: zscaler-category-add-ip
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category
      type: string
  - arguments:
    - description: The ID of the category to remove the specified URLs from. For example,
        RADIO_STATIONS. You can retrieve the category IDs by running the 'zscaler-get-categories'
        command.
      name: category-id
      required: true
    - description: A comma-separated list of URLs to remove from the specified category.
        For example, pandora.com,spotify.com.
      isArray: true
      name: url
      required: true
    description: Removes URLs from the specified category.
    name: zscaler-category-remove-url
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - description: The ID of the category to remove the specified IP addresses from.
        For example, RADIO_STATIONS. You can retrieve the category IDs by running
        the 'zscaler-get-categories' command.
      name: category-id
      required: true
    - description: A comma-separated list of IP addresses to remove from the specified
        category. For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: ip
      required: true
    description: Removes IP address from the specified category.
    name: zscaler-category-remove-ip
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to display the URLs of each category in the War Room. Default
        is 'false'.
      name: displayURL
      predefined:
      - "true"
      - "false"
    description: Retrieves a list of all categories.
    name: zscaler-get-categories
    outputs:
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.Name
      description: The name of the category.
      type: string
  - arguments: []
    description: Retrieves the Zscaler default blacklist.
    name: zscaler-get-blacklist
    outputs:
    - contextPath: Zscaler.Blacklist
      description: The Zscaler blacklist.
      type: string
  - arguments: []
    description: Retrieves the Zscaler default whitelist.
    name: zscaler-get-whitelist
    outputs:
    - contextPath: Zscaler.Whitelist
      description: The Zscaler whitelist.
      type: string
  - arguments:
    - description: The MD5 hash of a file.
      name: md5
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: The type of report. Possible values are 'full' or 'summary'. Default
        is 'full'.
      name: details
      predefined:
      - full
      - summary
    description: Retrieves a full or summary report of the file that was analyzed
      by Sandbox. The file is represented by the specified MD5 hash.
    name: zscaler-sandbox-report
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that tagged the file as malicious.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason the vendor tagged the file as malicious.
      type: string
    - contextPath: File.DetectedMalware
      description: The malware detected in the file.
      type: string
    - contextPath: File.FileType
      description: The file type.
      type: string
    - contextPath: DBotScore.Indicator
      description: The MD5 hash file that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The MD5 hash file type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor that calculated the DBot score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual DBot score.
      type: number
  - arguments: []
    description: Manually create a Zscaler login session. This command will also try
      to log out of the previous session.
    name: zscaler-login
  - arguments: []
    description: Logs out of the current Zscaler session.
    name: zscaler-logout
  - arguments: []
    description: Activates the changes executed by other Zscaler commands in this
      session.
    name: zscaler-activate-changes
  runonce: false
  script: |2



    ''' IMPORTS '''
    import requests
    import time
    import json
    import random

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    CLOUD_NAME = demisto.params()['cloud']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    API_KEY = str(demisto.params()['key'])
    BASE_URL = CLOUD_NAME + '/api/v1'
    USE_SSL = not demisto.params().get('insecure', False)
    PROXY = demisto.params().get('proxy', True)
    DEFAULT_HEADERS = {
        'content-type': 'application/json'
    }
    EXCEEDED_RATE_LIMIT_STATUS_CODE = 429
    MAX_SECONDS_TO_WAIT = 30
    SESSION_ID_KEY = 'session_id'
    ERROR_CODES_DICT = {
        400: 'Invalid or bad request',
        401: 'Session is not authenticated or timed out',
        403: 'One of the following permission errors occurred:\n-The API key was disabled by your service provider\n'
             '-User role has no access permissions or functional scope\n-A required SKU subscription is missing\n'
             'Contact support or your account team for assistance.',
        404: 'Resource does not exist',
        409: 'Request could not be processed because of possible edit conflict occurred. Another admin might be saving a '
             'configuration change at the same time. In this scenario, the client is expected to retry after a short '
             'time period.',
        415: 'Unsupported media type.',
        429: 'Exceeded the rate limit or quota.',
        500: 'Unexpected error',
        503: 'Service is temporarily unavailable'
    }
    AUTO_ACTIVATE_CHANGES_COMMANDS = (
        'zscaler-blacklist-url',
        'zscaler-undo-blacklist-url',
        'zscaler-whitelist-url',
        'zscaler-undo-whitelist-url',
        'zscaler-blacklist-ip',
        'zscaler-undo-blacklist-ip',
        'zscaler-whitelist-ip',
        'zscaler-undo-whitelist-ip',
        'zscaler-category-add-url',
        'zscaler-category-add-ip',
        'zscaler-category-remove-url',
        'zscaler-category-remove-ip'
    )

    ''' HANDLE PROXY '''
    if not PROXY:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' HELPER CLASSES '''


    class AuthorizationError(DemistoException):
        """Error to be raised when 401/403 headers are present in http response"""


    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, data=None, headers=None, num_of_seconds_to_wait=3):
        if headers is None:
            headers = DEFAULT_HEADERS
        data = {} if data is None else data
        url = BASE_URL + url_suffix
        try:
            res = requests.request(method,
                                   url,
                                   verify=USE_SSL,
                                   data=data,
                                   headers=headers
                                   )
            if res.status_code not in (200, 204):
                if res.status_code == EXCEEDED_RATE_LIMIT_STATUS_CODE and num_of_seconds_to_wait <= MAX_SECONDS_TO_WAIT:
                    random_num_of_seconds = random.randint(num_of_seconds_to_wait, num_of_seconds_to_wait + 3)
                    time.sleep(random_num_of_seconds)  # pylint: disable=sleep-exists
                    return http_request(method, url_suffix, data, headers=headers,
                                        num_of_seconds_to_wait=num_of_seconds_to_wait + 3)
                elif res.status_code in (401, 403):
                    raise AuthorizationError(res.content)
                else:
                    raise Exception('Your request failed with the following error: ' + ERROR_CODES_DICT[res.status_code])
        except Exception as e:
            LOG('Zscaler request failed with url={url}\tdata={data}'.format(url=url, data=data))
            LOG(e)
            raise e
        return res


    def validate_urls(urls):
        for url in urls:
            if url.startswith('http://') or url.startswith('https://'):
                return_error(
                    'Enter a valid URL address without an http:// or https:// prefix. URL should have at least host.'
                    'domain pattern to qualify.')


    ''' FUNCTIONS '''


    def login():
        """
        Try to use integration context if available and valid, otherwise create new session
        """
        cmd_url = '/authenticatedSession'

        def obfuscateApiKey(seed):
            now = str(int(time.time() * 1000))
            n = now[-6:]
            r = str(int(n) >> 1).zfill(6)
            key = ""
            for i in range(0, len(n), 1):
                key += seed[int(n[i])]
            for j in range(0, len(r), 1):
                key += seed[int(r[j]) + 2]
            return now, key
        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if session_id:
            DEFAULT_HEADERS['cookie'] = session_id
            try:
                return test_module()
            except AuthorizationError as e:
                demisto.info('Zscaler encountered an authentication error.\nError: {}'.format(str(e)))
        ts, key = obfuscateApiKey(API_KEY)
        data = {
            'username': USERNAME,
            'timestamp': ts,
            'password': PASSWORD,
            'apiKey': key
        }
        json_data = json.dumps(data)
        result = http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        auth = result.headers['Set-Cookie']
        ctx[SESSION_ID_KEY] = DEFAULT_HEADERS['cookie'] = auth[:auth.index(';')]
        set_integration_context(ctx)
        return test_module()


    def activate_changes():
        cmd_url = '/status/activate'
        return http_request('POST', cmd_url, None, DEFAULT_HEADERS)


    def logout():
        cmd_url = '/authenticatedSession'
        return http_request('DELETE', cmd_url, None, DEFAULT_HEADERS)


    def blacklist_url(url):
        urls_to_blacklist = argToList(url)
        validate_urls(urls_to_blacklist)
        cmd_url = '/security/advanced/blacklistUrls?action=ADD_TO_LIST'
        data = {
            'blacklistUrls': urls_to_blacklist
        }
        json_data = json.dumps(data)
        http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ''
        for url in urls_to_blacklist:
            list_of_urls += '- ' + url + '\n'
        return 'Added the following URLs to the blacklist successfully:\n' + list_of_urls


    def unblacklist_url(url):
        urls_to_unblacklist = argToList(url)
        cmd_url = '/security/advanced/blacklistUrls?action=REMOVE_FROM_LIST'

        # Check if given URLs is blacklisted
        blacklisted_urls = get_blacklist()['blacklistUrls']
        if len(urls_to_unblacklist) == 1:  # Given only one URL to unblacklist
            if urls_to_unblacklist[0] not in blacklisted_urls:
                raise Exception('Given URL is not blacklisted.')
        elif not any(url in urls_to_unblacklist for url in blacklisted_urls):  # Given more than one URL to blacklist
            raise Exception('Given URLs are not blacklisted.')

        data = {
            'blacklistUrls': urls_to_unblacklist
        }
        json_data = json.dumps(data)
        http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ''
        for url in urls_to_unblacklist:
            list_of_urls += '- ' + url + '\n'
        return 'Removed the following URLs from the blacklist successfully:\n' + list_of_urls


    def blacklist_ip(ip):
        ips_to_blacklist = argToList(ip)
        cmd_url = '/security/advanced/blacklistUrls?action=ADD_TO_LIST'
        data = {
            'blacklistUrls': ips_to_blacklist
        }
        json_data = json.dumps(data)
        http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ''
        for ip in ips_to_blacklist:
            list_of_ips += '- ' + ip + '\n'
        return 'Added the following IP addresses to the blacklist successfully:\n' + list_of_ips


    def unblacklist_ip(ip):
        ips_to_unblacklist = argToList(ip)
        cmd_url = '/security/advanced/blacklistUrls?action=REMOVE_FROM_LIST'
        # Check if given IPs is blacklisted
        blacklisted_ips = get_blacklist()['blacklistUrls']
        if len(ips_to_unblacklist) == 1:  # Given only one IP address to blacklist
            if ips_to_unblacklist[0] not in blacklisted_ips:
                raise Exception('Given IP address is not blacklisted.')
        elif not set(ips_to_unblacklist).issubset(set(blacklisted_ips)):  # Given more than one IP address to blacklist
            raise Exception('Given IP addresses are not blacklisted.')
        data = {
            'blacklistUrls': ips_to_unblacklist
        }
        json_data = json.dumps(data)
        http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ''
        for ip in ips_to_unblacklist:
            list_of_ips += '- ' + ip + '\n'
        return 'Removed the following IP addresses from the blacklist successfully:\n' + list_of_ips


    def whitelist_url(url):
        cmd_url = '/security'
        urls_to_whitelist = argToList(url)
        # Get the current whitelist
        whitelist_urls = get_whitelist()
        if not whitelist_urls:
            whitelist_urls['whitelistUrls'] = []

        whitelist_urls['whitelistUrls'] += urls_to_whitelist
        json_data = json.dumps(whitelist_urls)
        http_request('PUT', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ''
        for url in urls_to_whitelist:
            list_of_urls += '- ' + url + '\n'
        return 'Added the following URLs to the whitelist successfully:\n' + list_of_urls


    def unwhitelist_url(url):
        cmd_url = '/security'
        urls_to_unwhitelist = argToList(url)
        # Get the current whitelist
        whitelist_urls = get_whitelist()
        if not whitelist_urls:
            whitelist_urls['whitelistUrls'] = []

        # Check if given URL is whitelisted
        if len(urls_to_unwhitelist) == 1:  # Given only one URL to whitelist
            if urls_to_unwhitelist[0] not in whitelist_urls['whitelistUrls']:
                raise Exception('Given host address is not whitelisted.')
        elif not set(urls_to_unwhitelist).issubset(set(whitelist_urls['whitelistUrls'])):  # Given more than one URL to whitelist
            raise Exception('Given host addresses are not whitelisted.')
        # List comprehension to remove requested URLs from the whitelist
        whitelist_urls['whitelistUrls'] = [x for x in whitelist_urls['whitelistUrls'] if x not in urls_to_unwhitelist]
        json_data = json.dumps(whitelist_urls)
        http_request('PUT', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ''
        for url in whitelist_urls:
            list_of_urls += '- ' + url + '\n'
        return 'Removed the following URLs from the whitelist successfully:\n' + list_of_urls


    def whitelist_ip(ip):
        cmd_url = '/security'
        ips_to_whitelist = argToList(ip)
        # Get the current whitelist
        whitelist_ips = get_whitelist()
        if not whitelist_ips:
            whitelist_ips['whitelistUrls'] = []

        whitelist_ips['whitelistUrls'] += ips_to_whitelist
        json_data = json.dumps(whitelist_ips)
        http_request('PUT', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ''
        for ip in ips_to_whitelist:
            list_of_ips += '- ' + ip + '\n'
        return 'Added the following URLs to the whitelist successfully:\n' + list_of_ips


    def unwhitelist_ip(ip):
        cmd_url = '/security'
        ips_to_unwhitelist = argToList(ip)
        # Get the current whitelist
        whitelist_ips = get_whitelist()
        if not whitelist_ips:
            whitelist_ips['whitelistUrls'] = []

        # Check if given IP is whitelisted
        if len(ips_to_unwhitelist) == 1:  # Given only one IP to whitelist
            if ips_to_unwhitelist[0] not in whitelist_ips['whitelistUrls']:
                raise Exception('Given IP address is not whitelisted.')
        elif not set(ips_to_unwhitelist).issubset(set(whitelist_ips['whitelistUrls'])):  # Given more than one IP to whitelist
            raise Exception('Given IP address is not whitelisted.')
        # List comprehension to remove requested IPs from the whitelist
        whitelist_ips['whitelistUrls'] = [x for x in whitelist_ips['whitelistUrls'] if x not in ips_to_unwhitelist]
        json_data = json.dumps(whitelist_ips)
        http_request('PUT', cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ''
        for ip in ips_to_unwhitelist:
            list_of_ips += '- ' + ip + '\n'
        return 'Removed the following IP addresses from the whitelist successfully:\n' + list_of_ips


    def get_blacklist_command():
        blacklist = get_blacklist().get('blacklistUrls')
        if blacklist:
            hr = '### Zscaler blacklist\n'
            for url in blacklist:
                hr += '- ' + url + '\n'
            ec = {
                'Zscaler.Blacklist': blacklist
            }
            entry = {
                'Type': entryTypes['note'],
                'Contents': blacklist,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return 'No results found'


    def get_blacklist():
        cmd_url = '/security/advanced'
        result = http_request('GET', cmd_url, None, DEFAULT_HEADERS)
        return json.loads(result.content)


    def get_whitelist_command():
        whitelist = get_whitelist().get('whitelistUrls')
        if whitelist:
            hr = '### Zscaler whitelist\n'
            for url in whitelist:
                hr += '- ' + url + '\n'
            ec = {
                'Zscaler.Whitelist': whitelist
            }
            entry = {
                'Type': entryTypes['note'],
                'Contents': whitelist,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return 'No results found'


    def get_whitelist():
        cmd_url = '/security'
        result = http_request('GET', cmd_url, None, DEFAULT_HEADERS)
        return json.loads(result.content)


    def url_lookup(args):
        url = args.get('url', '')
        multiple = args.get('multiple', 'true').lower() == 'true'
        response = lookup_request(url, multiple)
        raw_res = json.loads(response.content)
        ec = dict()  # type: Dict[str, List]
        ec[outputPaths['url']] = []
        ec['DBotScore'] = []
        pre_table_data = []
        for data in raw_res:
            suspicious_categories = ['SUSPICIOUS_DESTINATION', 'SPYWARE_OR_ADWARE']
            ioc_context = {'Address': data['url'], 'Data': data['url']}
            score = 1
            if len(data['urlClassifications']) == 0:
                data['urlClassifications'] = ''
            else:
                data['urlClassifications'] = ''.join(data['urlClassifications'])
                ioc_context['urlClassifications'] = data['urlClassifications']
                if data['urlClassifications'] == 'MISCELLANEOUS_OR_UNKNOWN':
                    score = 0
            if len(data['urlClassificationsWithSecurityAlert']) == 0:
                data['urlClassificationsWithSecurityAlert'] = ''
            else:
                data['urlClassificationsWithSecurityAlert'] = ''.join(data['urlClassificationsWithSecurityAlert'])
                ioc_context['urlClassificationsWithSecurityAlert'] = data['urlClassificationsWithSecurityAlert']
                if data['urlClassificationsWithSecurityAlert'] in suspicious_categories:
                    score = 2
                else:
                    score = 3
                ioc_context['Malicious'] = {
                    'Vendor': 'Zscaler',
                    'Description': data['urlClassificationsWithSecurityAlert']
                }
                data['ip'] = data.pop('url')
            ioc_context = createContext(data=ioc_context, removeNull=True)
            ec[outputPaths['url']].append(ioc_context)
            ec['DBotScore'].append(
                {
                    "Indicator": data.get('url') or data.get('ip'),
                    "Score": score,
                    "Type": "url",
                    "Vendor": "Zscaler"
                }
            )
            pre_table_data.append(data)
        if ec[outputPaths['url']] or ec['DBotScore']:
            title = 'Zscaler URL Lookup'
            entry = {
                'Type': entryTypes['note'],
                'Contents': raw_res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, pre_table_data, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found.'  # type: ignore
        return entry


    def ip_lookup(ip):
        response = lookup_request(ip, multiple=True)
        hr = json.loads(response.content)
        if hr:
            ioc_context = [None] * len(hr)  # type: List[Any]
            suspicious_categories = ['SUSPICIOUS_DESTINATION', 'SPYWARE_OR_ADWARE']
            dbot_score_array = [None] * len(hr)  # type: List[Any]
            for i in range(len(hr)):
                ioc_context[i] = {}
                dbot_score_array[i] = {}
                ioc_context[i]['Address'] = hr[i]['url']
                dbot_score_array[i]['Indicator'] = hr[i]['url']
                score = 1
                if len(hr[i]['urlClassifications']) == 0:
                    hr[i]['iplClassifications'] = ''
                else:
                    hr[i]['ipClassifications'] = ''.join(hr[i]['urlClassifications'])
                    ioc_context[i]['ipClassifications'] = hr[i]['ipClassifications']
                del hr[i]['urlClassifications']
                if len(hr[i]['urlClassificationsWithSecurityAlert']) == 0:
                    hr[i]['ipClassificationsWithSecurityAlert'] = ''
                else:
                    hr[i]['ipClassificationsWithSecurityAlert'] = ''.join(hr[i]['urlClassificationsWithSecurityAlert'])
                    if hr[i]['urlClassificationsWithSecurityAlert'] in suspicious_categories:
                        score = 2
                    else:
                        score = 3
                    ioc_context[i]['Malicious'] = {
                        'Vendor': 'Zscaler',
                        'Description': hr[i]['ipClassificationsWithSecurityAlert']
                    }
                del hr[i]['urlClassificationsWithSecurityAlert']
                hr[i]['ip'] = hr[i].pop('url')
                dbot_score_array[i]['Score'] = score
                dbot_score_array[i]['Type'] = 'ip'
                dbot_score_array[i]['Vendor'] = 'Zscaler'

            ioc_context = createContext(data=ioc_context, removeNull=True)
            ec = {
                outputPaths['ip']: ioc_context,
                'DBotScore': dbot_score_array
            }
            title = 'Zscaler IP Lookup'
            entry = {
                'Type': entryTypes['note'],
                'Contents': hr,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, hr, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found.'  # type: ignore
        return entry


    def lookup_request(ioc, multiple=True):
        cmd_url = '/urlLookup'
        if multiple:
            ioc_list = argToList(ioc)
        else:
            ioc_list = [ioc]
        ioc_list = [url.replace('https://', '').replace('http://', '') for url in ioc_list]
        json_data = json.dumps(ioc_list)
        response = http_request('POST', cmd_url, json_data, DEFAULT_HEADERS)
        return response


    def category_add_url(category_id, url):
        categories = get_categories()
        found_category = False
        for category in categories:
            if category['id'] == category_id:
                category_data = category
                found_category = True
                break
        if found_category:
            url_list = argToList(url)
            all_urls = url_list[:]
            all_urls.extend(list(map(lambda x: x.strip(), category_data['urls'])))
            category_data['urls'] = all_urls
            category_ioc_update(category_data)
            context = {
                'ID': category_id,
                'CustomCategory': category_data['customCategory'],
                'URL': category_data['urls']
            }
            if 'description' in category_data and category_data['description']:  # Custom might not have description
                context['Description'] = category_data['description']
            ec = {
                'Zscaler.Category(val.ID && val.ID === obj.ID)': context
            }
            urls = ''
            for url in url_list:
                urls += '- ' + url + '\n'
            hr = 'Added the following URL addresses to category {}:\n{}'.format(category_id, urls)
            entry = {
                'Type': entryTypes['note'],
                'Contents': ec,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return return_error('Category could not be found.')


    def category_add_ip(category_id, ip):
        categories = get_categories()
        found_category = False
        for category in categories:
            if category['id'] == category_id:
                category_data = category
                found_category = True
                break
        if found_category:
            ip_list = argToList(ip)
            all_ips = ip_list[:]
            all_ips.extend(category_data['urls'])
            category_data['urls'] = all_ips
            response = category_ioc_update(category_data)
            context = {
                'ID': category_id,
                'CustomCategory': category_data['customCategory'],
                'URL': category_data['urls']
            }
            if 'description' in category_data and category_data['description']:  # Custom might not have description
                context['Description'] = category_data['description']
            ec = {
                'Zscaler.Category(val.ID && val.ID === obj.ID)': context
            }
            ips = ''
            for ip in ip_list:
                ips += '- ' + ip + '\n'
            hr = 'Added the following IP addresses to category {}:\n{}'.format(category_id, ips)
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return return_error('Category could not be found.')


    def category_remove_url(category_id, url):
        categories = get_categories()
        found_category = False
        for category in categories:
            if category['id'] == category_id:
                category_data = category
                found_category = True
                break
        if found_category:
            url_list = argToList(url)
            updated_urls = [url for url in category_data['urls'] if url not in url_list]  # noqa
            if updated_urls == category_data['urls']:
                return return_error('Could not find given URL in the category.')
            category_data['urls'] = updated_urls
            response = category_ioc_update(category_data)
            context = {
                'ID': category_id,
                'CustomCategory': category_data['customCategory'],
                'URL': category_data['urls']
            }
            if 'description' in category_data and category_data['description']:  # Custom might not have description
                context['Description'] = category_data['description']
            ec = {
                'Zscaler.Category(val.ID && val.ID === obj.ID)': context
            }
            urls = ''
            for url in url_list:
                urls += '- ' + url + '\n'
            hr = 'Removed the following URL addresses to category {}:\n{}'.format(category_id, urls)
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return return_error('Category could not be found.')


    def category_remove_ip(category_id, ip):
        categories = get_categories()
        found_category = False
        for category in categories:
            if category['id'] == category_id:
                category_data = category
                found_category = True
                break
        if found_category:
            ip_list = argToList(ip)
            updated_ips = [ip for ip in category_data['urls'] if ip not in ip_list]  # noqa
            if updated_ips == category_data['urls']:
                return return_error('Could not find given IP in the category.')
            category_data['urls'] = updated_ips
            response = category_ioc_update(category_data)
            context = {
                'ID': category_id,
                'CustomCategory': category_data['customCategory'],
                'URL': category_data['urls']
            }
            if 'description' in category_data and category_data['description']:  # Custom might not have description
                context['Description'] = category_data['description']
            ec = {
                'Zscaler.Category(val.ID && val.ID === obj.ID)': context
            }
            ips = ''
            for ip in ip_list:
                ips += '- ' + ip + '\n'
            hr = 'Removed the following IP addresses to category {}:\n{}'.format(category_id, ips)
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            }
            return entry
        else:
            return return_error('Category could not be found.')


    def category_ioc_update(category_data):
        cmd_url = '/urlCategories/' + category_data['id']
        data = {
            'customCategory': category_data['customCategory'],
            'urls': category_data['urls'],
            'id': category_data['id']
        }
        if 'description' in category_data:
            data['description'] = category_data['description']
        if 'configuredName' in category_data:
            data['configuredName'] = category_data['configuredName']
        json_data = json.dumps(data)
        response = http_request('PUT', cmd_url, json_data).json()
        return response


    def get_categories_command(display_url):
        display_urls = True if display_url == 'true' else False
        raw_categories = get_categories()
        categories = []
        for raw_category in raw_categories:
            category = {
                'ID': raw_category['id'],
                'CustomCategory': raw_category['customCategory']
            }
            if raw_category['urls']:
                category['URL'] = raw_category['urls']
            if 'description' in raw_category:
                category['Description'] = raw_category['description']
            if 'configuredName' in raw_category:
                category['Name'] = raw_category['configuredName']
            categories.append(category)
        ec = {
            'Zscaler.Category(val.ID && val.ID === obj.ID)': categories
        }
        if display_urls:
            headers = ['ID', 'Description', 'URL', 'CustomCategory', 'Name']
        else:
            headers = ['ID', 'Description', 'CustomCategory', 'Name']
        title = 'Zscaler Categories'
        entry = {
            'Type': entryTypes['note'],
            'Contents': raw_categories,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, categories, headers),
            'EntryContext': ec
        }
        return entry


    def get_categories():
        cmd_url = '/urlCategories'
        response = http_request('GET', cmd_url).json()
        return response


    def sandbox_report_command():
        md5 = demisto.getArg('md5')
        details = demisto.getArg('details')
        res = sandbox_report(md5, details)

        report = 'Full Details' if details == 'full' else 'Summary'
        ctype = demisto.get(res, '{}.Classification.Type'.format(report))
        dbot_score = 3 if ctype == "MALICIOUS" else 2 if ctype == "SUSPICIOUS" else 1 if ctype == "BENIGN" else 0

        ec = {outputPaths['dbotscore']: {
            'Indicator': md5,
            'Type': 'file',
            'Vendor': 'Zscaler',
            'Score': dbot_score
        }}

        human_readable_report = ec['DBotScore'].copy()
        human_readable_report["Detected Malware"] = str(
            demisto.get(res, '{}.Classification.DetectedMalware'.format(report)))
        human_readable_report["Zscaler Score"] = demisto.get(res, '{}.Classification.Score'.format(report))
        human_readable_report["Category"] = demisto.get(res, '{}.Classification.Category'.format(report))
        ec[outputPaths['file']] = {
            'MD5': md5,
            'Zscaler': {
                'DetectedMalware': demisto.get(res, '{}.Classification.DetectedMalware'.format(report)),
                'FileType': demisto.get(res, '{}.File Properties.File Type'.format(report)),
            }
        }
        if dbot_score == 3:
            ec[outputPaths['file']]['Malicious'] = {
                'Vendor': 'Zscaler',
                'Description': 'Classified as Malicious, with threat score: ' + str(human_readable_report["Zscaler Score"])
            }
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Full Sandbox Report', human_readable_report, removeNull=True),
            'EntryContext': ec
        })


    def sandbox_report(md5, details):
        cmd_url = '/sandbox/report/{md5Hash}?details={details}'.format(md5Hash=md5, details=details)

        response = http_request('GET', cmd_url).json()
        return response


    def login_command():
        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if session_id:
            try:
                DEFAULT_HEADERS['cookie'] = session_id
                demisto.info('Zscaler logout active session triggered by zscaler-login command.')
                logout()
            except Exception as e:
                demisto.info('Zscaler logout failed with: {}'.format(str(e)))
        login()
        return CommandResults(readable_output="Zscaler session created successfully.")


    def logout_command():
        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if not session_id:
            return CommandResults(
                readable_output="No API session was found. No action was performed."
            )
        try:
            DEFAULT_HEADERS['cookie'] = session_id
            raw_res = logout().json()
        except AuthorizationError:
            return CommandResults(
                readable_output="API session is not authenticated. No action was performed."
            )
        return CommandResults(
            readable_output="API session logged out of Zscaler successfully.",
            raw_response=raw_res
        )


    def activate_command():
        raw_res = activate_changes().json()
        return CommandResults(
            readable_output="Changes have been activated successfully.",
            raw_response=raw_res
        )


    def test_module():
        http_request('GET', '/status', None, DEFAULT_HEADERS)
        return 'ok'


    ''' EXECUTION CODE '''


    def main():
        LOG('command is %s' % (demisto.command(),))

        if demisto.command() == 'zscaler-login':
            return_results(login_command())
        elif demisto.command() == 'zscaler-logout':
            return_results(logout_command())
        else:
            login()
            try:
                if demisto.command() == 'test-module':
                    demisto.results(test_module())
                elif demisto.command() == 'url':
                    demisto.results(url_lookup(demisto.args()))
                elif demisto.command() == 'ip':
                    demisto.results(ip_lookup(demisto.args()['ip']))
                elif demisto.command() == 'zscaler-blacklist-url':
                    demisto.results(blacklist_url(demisto.args()['url']))
                elif demisto.command() == 'zscaler-undo-blacklist-url':
                    demisto.results(unblacklist_url(demisto.args()['url']))
                elif demisto.command() == 'zscaler-whitelist-url':
                    demisto.results(whitelist_url(demisto.args()['url']))
                elif demisto.command() == 'zscaler-undo-whitelist-url':
                    demisto.results(unwhitelist_url(demisto.args()['url']))
                elif demisto.command() == 'zscaler-blacklist-ip':
                    demisto.results(blacklist_ip(demisto.args()['ip']))
                elif demisto.command() == 'zscaler-undo-blacklist-ip':
                    demisto.results(unblacklist_ip(demisto.args()['ip']))
                elif demisto.command() == 'zscaler-whitelist-ip':
                    demisto.results(whitelist_ip(demisto.args()['ip']))
                elif demisto.command() == 'zscaler-undo-whitelist-ip':
                    demisto.results(unwhitelist_ip(demisto.args()['ip']))
                elif demisto.command() == 'zscaler-category-add-url':
                    demisto.results(category_add_url(demisto.args()['category-id'], demisto.args()['url']))
                elif demisto.command() == 'zscaler-category-add-ip':
                    demisto.results(category_add_ip(demisto.args()['category-id'], demisto.args()['ip']))
                elif demisto.command() == 'zscaler-category-remove-url':
                    demisto.results(category_remove_url(demisto.args()['category-id'], demisto.args()['url']))
                elif demisto.command() == 'zscaler-category-remove-ip':
                    demisto.results(category_remove_ip(demisto.args()['category-id'], demisto.args()['ip']))
                elif demisto.command() == 'zscaler-get-categories':
                    demisto.results(get_categories_command(demisto.args()['displayURL']))
                elif demisto.command() == 'zscaler-get-blacklist':
                    demisto.results(get_blacklist_command())
                elif demisto.command() == 'zscaler-get-whitelist':
                    demisto.results(get_whitelist_command())
                elif demisto.command() == 'zscaler-sandbox-report':
                    demisto.results(sandbox_report_command())
                elif demisto.command() == 'zscaler-activate-changes':
                    return_results(activate_command())
            except Exception as e:
                LOG(str(e))
                LOG.print_log()
                raise
            finally:
                try:
                    # activate changes only when required
                    if demisto.params().get('auto_activate') and demisto.command() in AUTO_ACTIVATE_CHANGES_COMMANDS:
                        activate_changes()
                    if demisto.params().get('auto_logout'):
                        logout()
                except Exception as err:
                    demisto.info("Zscaler error: " + str(err))


    # python2 uses __builtin__ python3 uses builtins
    if __name__ in ("__builtin__", "builtins", "__main__"):
        main()
  subtype: python2
  type: python
system: true
