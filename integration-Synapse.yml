category: Data Enrichment & Threat Intelligence
commonfields:
  id: Synapse
  version: -1
configuration:
- display: Server URL (e.g. https://synapse.vertex.link)
  name: url
  required: true
  type: 0
- defaultvalue: "4443"
  display: REST API Port (default is 4443).
  name: port
  required: true
  type: 0
- display: Username and password to user to authenticate to Synapse.
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: 'Optionally set display timezone for timestamps. Default is UTC.
    Ex: "US/Eastern"'
  display: Timezone (optional)
  name: timezone
  required: false
  type: 0
- additionalinfo: Tag that denotes indicator is malicious (i.e. "threat.mal" or "mal.foo.bar").
    Depends on custom tag heirarchy. Use highest heirarchical tag that is considered
    malicious.
  display: Malicious Tag
  name: bad_tag
  required: false
  type: 0
- additionalinfo: Tag that denotes indicator is benign (i.e. "omit.benign" or "legit.beign").
    Depends on custom tag heirarchy. Use highest heirarchical tag that is considered
    benign.
  display: Benign Tag
  name: good_tag
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: 1.0.0
    packID: Synapse
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Synapse intelligence analysis platform.
detaileddescription: "### Community Contributed Integration\n #### Integration Author:
  Jordan Berry\n No support or maintenance is provided by the author. Customers are
  encouraged to engage with the user community for questions and guidance at the [Cortex
  XSOAR Live Discussions](https://live.paloaltonetworks.com/t5/cortex-xsoar-discussions/bd-p/Cortex_XSOAR_Discussions).\n***\n##
  Synapse\n1. Create and start Synapse instance with remote access. See the Synapse
  documentation [here](https://synapse.docs.vertex.link/en/latest/synapse/quickstart.html).\n2.
  Configure the **Server URL** to match that of your remote cortex instance. \n3.
  Configure the **port** that was used for the REST API (default is `:4443`). \n4.
  Use your **username** and **password** for remote authentication.\n---\n[View Integration
  Documentation](https://xsoar.pan.dev/docs/reference/integrations/synapse)"
display: Synapse (Community Contribution)
image: data:image/png;base64,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
name: Synapse
script:
  commands:
  - arguments:
    - default: true
      description: List of IPs.
      isArray: true
      name: ip
      required: true
    description: Returns IP information and reputation.
    name: ip
    outputs:
    - contextPath: Synapse.IP.ip
      description: The IP address of the indicator.
      type: String
    - contextPath: Synapse.IP.tags
      description: The tags applied to the IP address.
      type: String
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: Number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
  - arguments:
    - default: true
      description: List of URLs.
      isArray: true
      name: url
      required: true
    description: Returns URL information and reputation.
    name: url
    outputs:
    - contextPath: Synapse.URL.url
      description: The data of the URL indicator.
      type: String
    - contextPath: Synapse.URL.tags
      description: The tags applied to the url.
      type: String
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: Number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: URL.Data
      description: The data of the URL indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
  - arguments:
    - default: true
      description: List of Domains.
      isArray: true
      name: domain
      required: true
    description: Returns Domain information and reputation.
    name: domain
    outputs:
    - contextPath: Synapse.Domain.domain
      description: The fully qualified domain name.
      type: String
    - contextPath: Synapse.Domain.tags
      description: The tags applied to the domain.
      type: String
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: Number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: Domain.Name
      description: The name of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
  - arguments:
    - default: true
      description: List of File Hashes (accepts MD5, SHA1, SHA256, SHA512).
      isArray: true
      name: file
      required: true
    description: Returns File information and reputation.
    name: file
    outputs:
    - contextPath: Synapse.File.hash
      description: The queried file hash.
      type: String
    - contextPath: Synapse.File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: Synapse.File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: Synapse.File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: Synapse.File.SHA512
      description: The SHA256 hash of the file.
      type: String
    - contextPath: Synapse.File.query
      description: The formatted query in storm syntax.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: String
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: String
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: String
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: Number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
  - arguments:
    - default: true
      description: Synapse storm query (i.e. "inet:ipv4=1.2.3.4")
      name: query
      required: true
    - defaultValue: "100"
      description: Limit the number of results returned. Default is 100.
      name: limit
    description: Execute a Synapse Storm query.
    name: synapse-storm-query
    outputs:
    - contextPath: Synapse.Nodes.created
      description: Timestamp when the node was first created in the Synapse Cortex.
      type: String
    - contextPath: Synapse.Nodes.form
      description: The type of node (i.e. "inet:ipv4" for an IP address).
      type: String
    - contextPath: Synapse.Nodes.tags
      description: The tags associated with the resulting node.
      type: String
    - contextPath: Synapse.Nodes.valu
      description: The node primary value (i.e. "1.2.3.4" for an IP).
      type: String
  - arguments: []
    description: Lists current users in Synapse Cortex.
    name: synapse-list-users
    outputs:
    - contextPath: Synapse.Users.Admin
      description: True/False whether the Synapse user is an admin.
      type: Boolean
    - contextPath: Synapse.Users.Email
      description: The email address of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Iden
      description: The unique identifier of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Name
      description: The user's Synapse username.
      type: String
    - contextPath: Synapse.Users.Roles
      description: The roles applied to the Synapse user.
      type: String
    - contextPath: Synapse.Users.Rules
      description: The rules applied to the Synapse user.
      type: String
  - arguments: []
    description: Lists current roles in Synapse Cortex.
    name: synapse-list-roles
    outputs:
    - contextPath: Synapse.Roles.Iden
      description: The unique identifier of the Synapse Role.
      type: String
    - contextPath: Synapse.Roles.Name
      description: The name of the Synapse Role.
      type: String
    - contextPath: Synapse.Roles.Rules
      description: The rules applied to the Synapse Role.
      type: String
  - arguments:
    - description: New username to be created.
      name: username
      required: true
    - description: Optionally set the new user's password.
      name: password
    description: Create a new Synapse user.
    name: synapse-create-user
    outputs:
    - contextPath: Synapse.Users.Admin
      description: True/False whether the Synapse user is an admin.
      type: Boolean
    - contextPath: Synapse.Users.Email
      description: The email address of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Iden
      description: The unique identifier of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Name
      description: The user's Synapse username.
      type: String
    - contextPath: Synapse.Users.Roles
      description: The roles applied to the Synapse user.
      type: String
    - contextPath: Synapse.Users.Rules
      description: The rules applied to the Synapse user.
      type: String
  - arguments:
    - description: New role to create in Synapse.
      name: role
      required: true
    description: Create a new Synapse role.
    name: synapse-create-role
    outputs:
    - contextPath: Synapse.Roles.Iden
      description: The unique identifier of the Synapse Role.
      type: String
    - contextPath: Synapse.Roles.Name
      description: The name of the Synapse Role.
      type: String
    - contextPath: Synapse.Roles.Rules
      description: The rules applied to the Synapse Role.
      type: String
  - arguments:
    - description: User's "iden" property - not the username.
      name: user
      required: true
    - description: Role's "iden" property - not the name of the role.
      name: role
      required: true
    description: Grants a user access to role based perrmissions.
    name: synapse-grant-user-role
    outputs:
    - contextPath: Synapse.Users.Admin
      description: True/False whether the Synapse user is an admin.
      type: Boolean
    - contextPath: Synapse.Users.Email
      description: The email address of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Iden
      description: The unique identifier of the Synapse user.
      type: String
    - contextPath: Synapse.Users.Name
      description: The user's Synapse username.
      type: String
    - contextPath: Synapse.Users.Roles
      description: The roles applied to the Synapse user.
      type: String
    - contextPath: Synapse.Users.Rules
      description: The rules applied to the Synapse user.
      type: String
  - arguments:
    - description: Type/Form query (i.e. "inet:ipv4" or "inet"fqdn")
      name: query
      required: true
    description: Query the Synapse data model and return details for given type or
      form (i.e. "inet:ipv4" for an IPv4 IP address).
    name: synapse-query-model
    outputs:
    - contextPath: Synapse.Model.Doc
      description: The docstring associated with the particular Synapse model element.
      type: String
    - contextPath: Synapse.Model.Example
      description: An example of the given Synapse element.
      type: String
    - contextPath: Synapse.Model.Form
      description: A form is the definition of an object in the Synapse data model
        (node).
      type: String
    - contextPath: Synapse.Model.Properties
      description: The unique properties associated with the given Synapse object.
      type: String
    - contextPath: Synapse.Model.Type
      description: A Type is the definition of a data element within the data model.
      type: String
    - contextPath: Synapse.Model.Valu
      description: The given value of the Synapse object type.
      type: String
  dockerimage: demisto/aiohttp:1.0.0.12410
  runonce: false
  script: |2



    import json
    import pytz
    import asyncio
    import aiohttp
    import urllib3
    import ipaddress
    import traceback
    from aiohttp import TCPConnector


    # Disable insecure warnings
    urllib3.disable_warnings()


    ''' CONSTANTS '''


    DATE_FORMAT = '%Y/%m/%d %H:%M:%S %Z'
    TIMEZONE = demisto.params().get('timezone', None)


    ''' CLIENT '''


    class Client(BaseClient):
        """
        Client class to interact with the service API
        """

        def __init__(self, base_url, username, password, proxy, **kwargs):
            self._base_url = base_url
            self.username = username
            self.password = password
            self.proxy = proxy
            self.auth = (username, password)
            self.aio_auth = aiohttp.BasicAuth(username, password)
            super(Client, self).__init__(base_url, **kwargs)

        def _check_for_error(self, resp):
            """
            Checks for custom synapse error message in JSON response.
            Raises error if so.
            """
            if resp.get('status') != 'ok':
                code = resp.get('code')
                mesg = resp.get('mesg')
                raise Exception(f'Synapse API Error: ({code}): {mesg}')

        def login(self):
            """
            Login to Synapse and validate credentials.
            """

            resp = self._http_request(
                method='POST',
                url_suffix='/login',
                json_data={"user": self.username, "passwd": self.password}
            )

            self._check_for_error(resp)

            return resp

        def add_user(self, new_user, new_passwd):
            """
            Adds a new user to Synapse with given password.
            """

            resp = self._http_request(
                method='POST',
                url_suffix='/auth/adduser',
                json_data={'name': new_user, 'passwd': new_passwd},
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        def add_role(self, new_role):
            """
            Adds a new user role to Synapse.
            """

            resp = self._http_request(
                method='POST',
                url_suffix='/auth/addrole',
                json_data={'name': new_role},
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        def grant_role(self, user, role):
            """
            Adds a new user role to Synapse.
            """

            resp = self._http_request(
                method='POST',
                url_suffix='/auth/grant',
                json_data={'user': user, 'role': role},
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        def list_users(self):
            """
            Collects all users in Synapse.
            """

            resp = self._http_request(
                method='GET',
                url_suffix='/auth/users',
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        def list_roles(self):
            """
            Collects all user roles in Synapse.
            """

            resp = self._http_request(
                method='GET',
                url_suffix='/auth/roles',
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        def get_model(self):
            """
            Queries and returns full model json.
            """

            resp = self._http_request(
                method='GET',
                url_suffix='/model',
                auth=self.auth
            )

            self._check_for_error(resp)

            return resp

        async def synapse_get_nodes(self, data, limit=100):
            """
            Async function to query for Synapse nodes via storm.
            """
            my_query = f'{data} | limit {limit}'
            nodes = []  # Nodes to return
            async with aiohttp.ClientSession(
                connector=TCPConnector(ssl=self._verify),
                trust_env=self.proxy
            ) as sess:
                address = urljoin(self._base_url, '/storm')
                query = {'query': my_query}
                async with sess.get(address, json=query, auth=self.aio_auth) as resp:
                    async for byts, x in resp.content.iter_chunks():
                        if not byts:
                            break
                        mesg = json.loads(byts)
                        if mesg[0] == 'node':
                            nodes.append(mesg[1])
            return nodes


    ''' HELPER FUNCTIONS '''


    def validate_timezone_helper(TIMEZONE):
        """
        Validates Timezone format is correct before assuming it is.
        """
        if TIMEZONE not in pytz.all_timezones:
            return_error(f'Error: Timezone format "{TIMEZONE}" invalid')
        else:
            tz = pytz.timezone(TIMEZONE)
        return tz


    def convert_raw_into_nodes_helper(results):
        """
        Accepts raw node json and returns formatted list of dicts (nodes).
        """

        nodes = []
        for item in results:
            t_stamp = convert_epoch_timestamp_helper(item[1]['props'].get('.created'))
            node = {
                'form': item[0][0],
                'created': t_stamp,
                'tags': get_full_tags_helper(item[1].get('tags'))
            }
            if item[0][0] == 'inet:ipv4':
                node['valu'] = ipaddress.ip_address(item[0][1]).__str__()
            else:
                node['valu'] = item[0][1]
            nodes.append(node)
        return nodes


    def get_full_tags_helper(data):
        """
        Accepts raw REST Response for tags key and returns list of longest heirarchical tags.
        """
        tags = []

        temp_tags = [t for t in data.keys()]
        if temp_tags:
            tags.append(temp_tags.pop(0))
        else:
            return tags

        for i in range(0, len(temp_tags)):
            if temp_tags:
                temp = temp_tags.pop(0)
            else:
                break
            for tag in tags:
                if temp in tag:
                    continue
                elif tag in temp:
                    tags.remove(tag)
                    tags.append(temp)
                else:
                    tags.append(temp)
        return tags


    def convert_epoch_timestamp_helper(timestamp):
        """
        Accepts Epoch timestamp and localizes to UTC (timestamps per Synapse are all in UTC).
        """

        raw_date = datetime.fromtimestamp(float(timestamp) / 1000.)
        utc_date = raw_date.replace(tzinfo=pytz.UTC)

        if TIMEZONE:
            tz = validate_timezone_helper(TIMEZONE)
            current_date = utc_date.astimezone(tz)
            return current_date.strftime(DATE_FORMAT)
        else:
            return utc_date.strftime(DATE_FORMAT)


    def model_query_helper(model, query):
        """
        Accepts model (full json) and a node type (str) to query.
        Returns properties for given node type. Raises error not found if not present.
        """
        parsed_data = {'query': query}
        mod_types = [t for t in model['types'].keys()]
        mod_forms = [f for f in model['forms'].keys()]

        if (query not in mod_types) and (query not in mod_forms):
            raise Exception(f'Error: Query "{query}" not found in model. Try adjusting syntax (i.e. "inet:ipv4").')

        parsed_data['type'] = model['types'].get(query)

        if query in mod_forms:
            parsed_data['form'] = model['forms'].get(query)

        return parsed_data


    def model_query_properties_helper(form):
        """
        Accepts JSON of cortex form and returns formatted properties.
        """
        data = {}
        for prop, valu in form.get('props').items():
            data[prop] = valu.get('doc', 'N/A')

        return data


    def user_roles_helper(client, roles):
        """
        Accepts list of role identifiers and converts them to named roles. Return list of names.
        """
        data = client.list_roles()
        named_roles = []

        for role in data.get('result'):
            if role.get('iden') in roles:
                named_roles.append(role.get('name'))

        return named_roles


    def user_rules_helper(rules):
        """
        Accepts REST rules response and returns list of joined rules.
        """
        new_rules = []
        if not rules:
            return rules
        for rule in rules:
            if rule[0]:
                new_rules.append('.'.join(rule[1]))
        return new_rules


    def file_regex_helper(hash):
        """
        Accepts a raw hash and regex matches to determine what type.
        """

        if re.match(md5Regex, hash):
            file_query = f'file:bytes:md5={hash}'
        elif re.match(sha1Regex, hash):
            file_query = f'file:bytes:sha1={hash}'
        elif re.match(sha256Regex, hash):
            file_query = f'file:bytes:sha256={hash}'
        elif re.match(sha512Regex, hash):
            file_query = f'file:bytes:sha512={hash}'
        else:
            raise ValueError(f'Value "{hash}" is not a valid File Hash.')

        return file_query


    def file_context_builder_helper(file, data):
        """
        Accepts hash and parsed query response. Adds MD5, SHA1, SHA256, SHA512.
        """
        file_context = {
            'hash': file,
            'tags': get_full_tags_helper(data[0][1].get('tags'))
        }
        if data[0][1]['props'].get('md5'):
            file_context['MD5'] = data[0][1]['props'].get('md5')
        if data[0][1]['props'].get('sha1'):
            file_context['SHA1'] = data[0][1]['props'].get('sha1')
        if data[0][1]['props'].get('sha256'):
            file_context['SHA256'] = data[0][1]['props'].get('sha256')
        if data[0][1]['props'].get('sha512'):
            file_context['SHA512'] = data[0][1]['props'].get('sha512')

        return file_context


    ''' COMMAND FUNCTIONS '''


    def test_module(client):
        """
        Tests API connectivity and authentication'
        """
        client.login()
        return 'ok'


    def ip_reputation_command(client, args, good_tag, bad_tag):
        """
        Returns IP Reputation for a list of IPs.
        """

        ip_standard_list = []
        ip_data_list = []

        ips = argToList(args.get('ip'))
        if len(ips) == 0:
            raise ValueError('IP(s) not specified')

        for ip in ips:
            if not re.match(ipv4Regex, ip):
                raise ValueError(f'Value "{ip}" is not a valid IP address.')

        for ip in ips:
            query = f'inet:ipv4={ip}'
            data = asyncio.run(client.synapse_get_nodes(query))
            if not data:
                continue
            ip_data = {
                'ip': ip,
                'tags': get_full_tags_helper(data[0][1].get('tags'))
            }

            score = Common.DBotScore.NONE  # unknown
            reputation = {'tag': 'N/A'}
            if bad_tag in ip_data['tags']:
                score = Common.DBotScore.BAD  # bad
                reputation['tag'] = bad_tag
            elif good_tag in ip_data['tags']:
                score = Common.DBotScore.GOOD  # good
                reputation['tag'] = good_tag

            # Create the DBotScore structure first using the Common.DBotScore class.
            dbot_score = Common.DBotScore(
                indicator=ip,
                indicator_type=DBotScoreType.IP,
                integration_name='Synapse',
                score=score,
                malicious_description=f'Synapse returned reputation tag: {reputation["tag"]}'
            )

            # Create the IP Standard Context structure using Common.IP and add
            # dbot_score to it.
            ip_standard_context = Common.IP(
                ip=ip,
                dbot_score=dbot_score
            )

            ip_standard_list.append(ip_standard_context)
            ip_data_list.append(ip_data)

        readable_output = tableToMarkdown('IP List', ip_data_list)

        results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='Synapse.IP',
            outputs_key_field='ip',
            outputs=ip_data_list,
            indicators=ip_standard_list
        )

        return results


    def domain_reputation_command(client, args, good_tag, bad_tag):
        """
        Returns Domain Reputation for a list of Domains.
        """

        domain_standard_list = []
        domain_data_list = []

        domains = argToList(args.get('domain'))
        if len(domains) == 0:
            raise ValueError('Domain(s) not specified')

        for domain in domains:
            query = f'inet:fqdn={domain}'
            data = asyncio.run(client.synapse_get_nodes(query))
            if not data:
                continue
            domain_data = {
                'domain': domain,
                'tags': get_full_tags_helper(data[0][1].get('tags'))
            }

            score = Common.DBotScore.NONE  # unknown
            reputation = {'tag': 'N/A'}
            if bad_tag in domain_data['tags']:
                score = Common.DBotScore.BAD  # bad
                reputation['tag'] = bad_tag
            elif good_tag in domain_data['tags']:
                score = Common.DBotScore.GOOD  # good
                reputation['tag'] = good_tag

            # Create the DBotScore structure first using the Common.DBotScore class.
            dbot_score = Common.DBotScore(
                indicator=domain,
                indicator_type=DBotScoreType.DOMAIN,
                integration_name='Synapse',
                score=score,
                malicious_description=f'Synapse returned reputation tag: {reputation["tag"]}'
            )

            # Create the Domain Standard Context structure using Common.Domain and add
            # dbot_score to it.
            domain_standard_context = Common.Domain(
                domain=domain,
                dbot_score=dbot_score
            )

            domain_standard_list.append(domain_standard_context)
            domain_data_list.append(domain_data)

        readable_output = tableToMarkdown('Domain List', domain_data_list)

        results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='Synapse.Domain',
            outputs_key_field='domain',
            outputs=domain_data_list,
            indicators=domain_standard_list
        )

        return results


    def url_reputation_command(client, args, good_tag, bad_tag):
        """
        Returns URL Reputation for a list of URLs.
        """

        url_standard_list = []
        url_data_list = []

        urls = argToList(args.get('url'))
        if len(urls) == 0:
            raise ValueError('URL(s) not specified')

        for url in urls:
            if not re.match(urlRegex, url):
                raise ValueError(f'Value "{url}" is not a valid URL address.')

        for url in urls:
            query = f'inet:url={url}'
            data = asyncio.run(client.synapse_get_nodes(query))
            if not data:
                continue
            url_data = {
                'url': url,
                'tags': get_full_tags_helper(data[0][1].get('tags'))
            }

            score = Common.DBotScore.NONE  # unknown
            reputation = {'tag': 'N/A'}
            if bad_tag in url_data['tags']:
                score = Common.DBotScore.BAD  # bad
                reputation['tag'] = bad_tag
            elif good_tag in url_data['tags']:
                score = Common.DBotScore.GOOD  # good
                reputation['tag'] = good_tag

            # Create the DBotScore structure first using the Common.DBotScore class.
            dbot_score = Common.DBotScore(
                indicator=url,
                indicator_type=DBotScoreType.URL,
                integration_name='Synapse',
                score=score,
                malicious_description=f'Synapse returned reputation tag: {reputation["tag"]}'
            )

            # Create the URL Standard Context structure using Common.URL and add
            # dbot_score to it.
            url_standard_context = Common.URL(
                url=url,
                dbot_score=dbot_score
            )

            url_standard_list.append(url_standard_context)
            url_data_list.append(url_data)

        readable_output = tableToMarkdown('URL List', url_data_list)

        results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='Synapse.URL',
            outputs_key_field='url',
            outputs=url_data_list,
            indicators=url_standard_list
        )

        return results


    def file_reputation_command(client, args, good_tag, bad_tag):
        """
        Returns File Reputation for a list of hashes (MD5, SHA1, or SHA256).
        """

        file_standard_list = []
        file_data_list = []

        files = argToList(args.get('file'))
        if len(files) == 0:
            raise ValueError('File(s) not specified')

        for file in files:
            file_query = file_regex_helper(file)
            data = asyncio.run(client.synapse_get_nodes(file_query))
            if not data:
                continue
            file_data = file_context_builder_helper(file, data)
            file_data['query'] = file_query

            score = Common.DBotScore.NONE  # unknown
            reputation = {'tag': 'N/A'}
            if bad_tag in file_data['tags']:
                score = Common.DBotScore.BAD  # bad
                reputation['tag'] = bad_tag
            elif good_tag in file_data['tags']:
                score = Common.DBotScore.GOOD  # good
                reputation['tag'] = good_tag

            # Create the DBotScore structure first using the Common.DBotScore class.
            dbot_score = Common.DBotScore(
                indicator=file,
                indicator_type=DBotScoreType.FILE,
                integration_name='Synapse',
                score=score,
                malicious_description=f'Synapse returned reputation tag: {reputation["tag"]}'
            )

            # Create the File Standard Context structure using Common.File and add
            # dbot_score to it.
            file_standard_context = Common.File(
                md5=file_data.get('MD5'),
                sha1=file_data.get('SHA1'),
                sha256=file_data.get('SHA256'),
                sha512=file_data.get('SHA512'),
                dbot_score=dbot_score
            )

            file_standard_list.append(file_standard_context)
            file_data_list.append(file_data)

        readable_output = tableToMarkdown('File List', file_data_list)

        results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='Synapse.File',
            outputs_key_field='hash',
            outputs=file_data_list,
            indicators=file_standard_list
        )

        return results


    def storm_query_command(client, args):
        """
        Executes a storm query and expects nodes in response.
        """
        try:
            data = asyncio.run(client.synapse_get_nodes(args.get('query'), args.get('limit')))
        except DemistoException as e:
            if 'AuthDeny' in str(e):
                return 'Authorization Error: make sure credentials are correct set'
            else:
                raise e
        else:
            nodes = convert_raw_into_nodes_helper(data)

        name = f'Synapse Query Results: `{args.get("query")}`'
        headers = ['form', 'valu', 'created', 'tags']
        readable_output = tableToMarkdown(name, nodes, headers=headers, removeNull=True)

        if len(nodes) == 1:
            name_single = 'Synapse Node Properties'
            headers_single = [h for h in data[0][1]['props'].keys()]
            readable_output += tableToMarkdown(name_single, data[0][1]['props'], headers=headers_single, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Nodes',
            outputs_key_field='valu',
            outputs=nodes,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def list_users_command(client):
        """
        Executes API call for list users and returns response.
        """

        data = client.list_users()
        users = []

        for user in data.get('result'):
            my_user = {
                'Name': user.get('name'),
                'Email': user.get('email'),
                'Admin': user.get('admin'),
                'Iden': user.get('iden'),
                'Rules': user_rules_helper(user.get('rules')),
                'Roles': user_roles_helper(client, user.get('roles'))
            }
            users.append(my_user)

        name = 'Synapse Users'
        headers = ['Name', 'Email', 'Admin', 'Rules', 'Roles']
        readable_output = tableToMarkdown(name, users, headers=headers, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Users',
            outputs_key_field='Iden',
            outputs=users,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def list_roles_command(client):
        """
        Executes API call for list roles and returns response.
        """

        data = client.list_roles()
        roles = []

        for role in data.get('result'):
            my_role = {
                'Name': role.get('name'),
                'Iden': role.get('iden'),
                'Rules': user_rules_helper(role.get('rules'))
            }
            roles.append(my_role)

        name = 'Synapse Roles'
        headers = ['Name', 'Iden', 'Rules']
        readable_output = tableToMarkdown(name, roles, headers=headers, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Roles',
            outputs_key_field='Iden',
            outputs=roles,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def add_user_command(client, args):
        """
        Add a user to Synapse. Accepts username and password.
        """

        data = client.add_user(args.get('username'), args.get('password'))
        user = data.get('result')

        my_user = {
            'Name': user.get('name'),
            'Email': user.get('email'),
            'Admin': user.get('admin'),
            'Iden': user.get('iden'),
            'Rules': user_rules_helper(user.get('rules')),
            'Roles': user_roles_helper(client, user.get('roles'))
        }

        name = 'Synapse New User'
        headers = ['Name', 'Email', 'Admin', 'Rules', 'Roles']
        readable_output = tableToMarkdown(name, my_user, headers=headers, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Users',
            outputs_key_field='Iden',
            outputs=my_user,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def add_role_command(client, args):
        """
        Add a role to Synapse. Accepts new role.
        """

        data = client.add_role(args.get('role'))
        role = data.get('result')

        my_role = {
            'Name': role.get('name'),
            'Iden': role.get('iden'),
            'Rules': user_rules_helper(role.get('rules')),
        }

        name = 'Synapse New Role'
        headers = ['Name', 'Iden', 'Rules']
        readable_output = tableToMarkdown(name, my_role, headers=headers, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Roles',
            outputs_key_field='Iden',
            outputs=my_role,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def grant_user_role_command(client, args):
        """
        Grant role to a user.
        """

        data = client.grant_role(args.get('user'), args.get('role'))

        user = data.get('result')

        my_user = {
            'Name': user.get('name'),
            'Email': user.get('email'),
            'Admin': user.get('admin'),
            'Iden': user.get('iden'),
            'Rules': user_rules_helper(user.get('rules')),
            'Roles': user_roles_helper(client, user.get('roles'))
        }

        name = 'Synapse New User Role'
        headers = ['Name', 'Email', 'Admin', 'Rules', 'Roles']
        readable_output = tableToMarkdown(name, my_user, headers=headers, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Users',
            outputs_key_field='Iden',
            outputs=my_user,
            readable_output=readable_output,
            raw_response=data
        )

        return results


    def query_model_command(client, args):
        """
        Accepts a node type (str) to query and returns docs and properties.
        """

        data = client.get_model()
        model_resp = model_query_helper(data.get('result'), args.get('query').lower())
        q_type, q_form = {}, {}

        if model_resp.get('type'):
            q_type = {
                'Type': model_resp.get('query'),
                'Doc': model_resp['type']['info'].get('doc', 'N/A'),
                'Example': model_resp['type']['info'].get('ex', 'N/A')
            }
        if model_resp.get('form'):
            q_form = {
                'Form': model_resp.get('query'),
                'Properties': model_query_properties_helper(model_resp.get('form'))
            }
        full_resp = {
            'Valu': model_resp.get('query')
        }

        full_resp.update(q_type)
        full_resp.update(q_form)

        name = 'Synapse Model Type'
        headers = ['Type', 'Doc', 'Example']
        readable_output = tableToMarkdown(name, q_type, headers=headers, removeNull=False)

        if full_resp.get('Form'):
            name_form = f'Synapse `{full_resp.get("Valu")}` Form Properties'
            headers_form = [h for h in q_form['Properties'].keys()]
            readable_output += tableToMarkdown(name_form, q_form['Properties'], headers=headers_form, removeNull=False)

        results = CommandResults(
            outputs_prefix='Synapse.Model',
            outputs_key_field='Valu',
            outputs=full_resp,
            readable_output=readable_output,
            raw_response=model_resp
        )

        return results


    ''' MAIN FUNCTION '''


    def main() -> None:
        """
        main function, parses params and runs command functions
        """
        username = demisto.params().get('credentials').get('identifier')
        password = demisto.params().get('credentials').get('password')
        port = demisto.params().get('port')
        base = demisto.params()['url'].rstrip('/') + ':' + str(port)
        base_url = urljoin(base, '/api/v1')
        use_ssl = not demisto.params().get('insecure', False)
        use_proxy = demisto.params().get('proxy', False)
        good_tag = demisto.params().get('good_tag')
        bad_tag = demisto.params().get('bad_tag')

        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            client = Client(
                base_url=base_url,
                username=username,
                password=password,
                verify=use_ssl,
                proxy=use_proxy
            )

            if demisto.command() == 'test-module':
                return_results(test_module(client))

            elif demisto.command() == 'ip':
                return_results(ip_reputation_command(client, demisto.args(), good_tag, bad_tag))

            elif demisto.command() == 'domain':
                return_results(domain_reputation_command(client, demisto.args(), good_tag, bad_tag))

            elif demisto.command() == 'url':
                return_results(url_reputation_command(client, demisto.args(), good_tag, bad_tag))

            elif demisto.command() == 'file':
                return_results(file_reputation_command(client, demisto.args(), good_tag, bad_tag))

            elif demisto.command() == 'synapse-storm-query':
                return_results(storm_query_command(client, demisto.args()))

            elif demisto.command() == 'synapse-list-users':
                return_results(list_users_command(client))

            elif demisto.command() == 'synapse-list-roles':
                return_results(list_roles_command(client))

            elif demisto.command() == 'synapse-create-user':
                return_results(add_user_command(client, demisto.args()))

            elif demisto.command() == 'synapse-create-role':
                return_results(add_role_command(client, demisto.args()))

            elif demisto.command() == 'synapse-grant-user-role':
                return_results(grant_user_role_command(client, demisto.args()))

            elif demisto.command() == 'synapse-query-model':
                return_results(query_model_command(client, demisto.args()))

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
system: true
