category: Authentication
commonfields:
  id: CrowdStrikeMalquery
  version: -1
configuration:
- defaultvalue: https://api.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: base_url
  required: true
  type: 0
- display: Client ID
  name: client_id
  required: true
  type: 4
- display: Client Secret
  name: client_secret
  required: true
  type: 4
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: 1.0.0
    packID: CrowdStrikeMalquery
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Use the MalQuery Integration to query the contents of clean and malicious
  binary files, which forms part of Falcon's search engine.
detaileddescription: |
  ## CrowdStrike Malquery
  - Use the MalQuery to query the contents of clean and malicious files, which forms part of Falcon's search engine.

  ### Creating an API client
  You must have the Falcon Administrator role to view, create, or modify API clients or keys. You can only see an API client's secret when you create or reset the secret.
  1. Sign in to the Falcon console.
  2. Go to Support > API Clients and Keys.
  3. Click ***Add new API client***
  4. Enter a descriptive ***Client name*** that identifies your API client in Falcon and in API action logs.
  5. Select one or more API scopes.
  6. Click **Add**.

  ***Tip***: Record your API client secret somewhere safe. For security purposes, it's only shown when you create or reset the API client. If you lose your secret, you must reset it, which removes access for any integrations that still use the previous secret.
display: CrowdStrike Malquery
image: data:image/png;base64,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
name: CrowdStrikeMalquery
script:
  commands:
  - arguments:
    - description: The hex pattern to search. For example, deadbeef0102 (for bytes
        de, ad, be, ef, 01, 02).
      name: hex
    - description: The ASCII pattern to search. For example, CrowdStrike.
      name: ascii
    - description: The wide string pattern to search. For example, CrowdStrike.
      name: wide
    - description: The maximum number of results to be returned. Default is 100.
      name: limit
    - description: The maximum file size. The value can be specified either in bytes
        or in multiples of KB/MB/GB. For example, 128000, 1.3 KB, 8mb.
      name: max_size
    - description: The minimum file size. The value can be specified either in bytes
        or in multiples of KB/MB/GB. For example, 128000, 1.3 KB, 8mb.
      name: min_size
    - description: Limits results to files first seen before this date. The format
        is YYYY/MM/DD. For example, 2018/01/31.
      name: max_date
    - description: Limits results to files first seen after this date. The format
        is YYYY/MM/DD. For example, 2018/01/31.
      name: min_date
    - description: Limits results to certain file types such as EMAIL, PCAP, PDF,
        PE32. Comma separated values. For a full list of file types, see the MalQuery
        API documentation.
      isArray: true
      name: filter_filetypes
    - description: Specifies a subset of metadata fields to return in the results.
        Possible values - sha256, md5, type, size, first_seen, label, family. Comma
        separated values.
      isArray: true
      name: filter_meta
    description: Searches Falcon MalQuery for a combination of hex patterns and strings
      to identify malware samples based upon file content, which returns a request
      ID. Use the request ID in the cs-malquery-get-request command to   retrieve
      results. You can filter results based on criteria such as file type, file size
      and first seen date.
    name: cs-malquery-exact-search
    outputs:
    - contextPath: Malquery.Request_ID
      description: The request ID.
      type: String
  - arguments:
    - description: The YARA rule to search.
      name: yara_rule
    - description: A YAR file entry ID that contains the YARA rule to search. Only
        one Yara rule per request.
      name: yar_file_entry_id
    - description: The maximum number of results to be returned.
      name: limit
    - description: The maximum file size. The value can be specified either in bytes
        or in multiples of KB/MB/GB. For example, 128000, 1.3 KB, 8mb.
      name: max_size
    - description: The minimum file size. For example, 128000, 1.3 KB, 8mb.
      name: min_size
    - description: Limits results to files first seen before this date. The format
        is YYYY/MM/DD. For example, 2018/01/31.
      name: max_date
    - description: Limits results to files first seen after this date. The format
        is YYYY/MM/DD. For example, 2018/01/31.
      name: min_date
    - description: Limits results to files of certain types such as EMAIL, PCAP, PDF,
        PE32. Comma separated values. For a full list of types, see the MalQuery API
        documentation.
      isArray: true
      name: filter_filetypes
    - description: Specifies a subset of metadata fields to return in the results.
        Possible values - sha256, md5, type, size, first_seen, label, family. Comma
        separated values.
      isArray: true
      name: filter_meta
    description: Schedules a YARA rule-based search for execution, which returns a
      request ID. Use the request ID in the cs-malquery-get-request command to retrieve
      results. You can filter based on criteria such as file type, file size and first
      seen date.
    name: cs-malquery-hunt
    outputs:
    - contextPath: Malquery.Request_ID
      description: The request ID.
      type: String
  - arguments:
    - description: The hex pattern to search. For example, deadbeef0102 (for bytes
        de, ad, be, ef, 01, 02).
      name: hex
    - description: The ASCII pattern to search. For example, CrowdStrike.
      name: ascii
    - description: The wide string pattern to search. For example, CrowdStrike.
      name: wide
    - description: The maximum number of results to be returned. Default is 100.
      name: limit
    - description: Specifies a subset of metadata fields to return in the results.
        Possible values - sha256, md5, type, size, first_seen, label, family. Comma
        separated values.
      isArray: true
      name: filter_meta
    description: Searches Falcon MalQuery quickly. Uses partial matching, but with
      more potential for false positives. Search for a combination of hex patterns
      and strings to identify samples based upon file content.
    name: cs-malquery-fuzzy-search
    outputs:
    - contextPath: Malquery.File.family
      description: The malware family of the file. For example, StoneDrill.
      type: String
    - contextPath: Malquery.File.filesize
      description: The size of the file.
      type: String
    - contextPath: Malquery.File.filetype
      description: The type of the file.
      type: String
    - contextPath: Malquery.File.first_seen
      description: The date when the file was first seen.
      type: String
    - contextPath: Malquery.File.label
      description: The label of the file. For example, Malware.
      type: String
    - contextPath: Malquery.File.md5
      description: The MD5 of the file.
      type: String
    - contextPath: Malquery.File.sha1
      description: The SHA1 of the file.
      type: String
    - contextPath: Malquery.File.sha256
      description: The SHA256 of the file.
      type: String
  - arguments:
    - description: The identifier of a MalQuery request.
      name: request_id
      required: true
    description: Checks the status and results of an asynchronous request, such as
      hunt or exact-search.  Supports a single request ID.
    name: cs-malquery-get-request
    outputs:
    - contextPath: Malquery.Request_ID
      description: The request ID.
      type: String
    - contextPath: Malquery.Status
      description: The status of the request.
      type: String
    - contextPath: Malquery.File.family
      description: The malware family of the file. For example, StoneDrill.
      type: String
    - contextPath: Malquery.File.filesize
      description: The size of the file.
      type: String
    - contextPath: Malquery.File.filetype
      description: The type of the file. For example, PE32.
      type: String
    - contextPath: Malquery.File.first_seen
      description: The date when the file was first seen.
      type: String
    - contextPath: Malquery.File.label
      description: The label of the file. For example, malware.
      type: String
    - contextPath: Malquery.File.md5
      description: The file MD5.
      type: String
    - contextPath: Malquery.File.sha1
      description: The file SHA1.
      type: String
    - contextPath: Malquery.File.sha256
      description: The file SHA256.
      type: String
  - arguments: []
    description: Returns information about search and download quotas in your environment.
    name: cs-malquery-get-ratelimit
    outputs:
    - contextPath: Malquery.Quota.hunt_count
      description: How many hunts were executed in the last month.
      type: number
    - contextPath: Malquery.Quota.download_count
      description: How many downloads were executed in the last month.
      type: number
    - contextPath: Malquery.Quota.monitor_count
      description: How many monitors were created in the last month.
      type: number
    - contextPath: Malquery.Quota.hunt_limit
      description: Total hunt limit per month.
      type: number
    - contextPath: Malquery.Quota.download_limit
      description: The total download limit per month.
      type: number
    - contextPath: Malquery.Quota.monitor_limit
      description: The total monitor limit per month.
      type: number
    - contextPath: Malquery.Quota.refresh_time
      description: The time when the limits are refreshed. ISO 8601 format.
      type: string
    - contextPath: Malquery.Quota.days_left
      description: The days left until the limits are refreshed.
      type: number
    - contextPath: Malquery.Quota.hunt_counts.userid
      description: The download counts per user.
      type: String
    - contextPath: Malquery.Quota.hunt_counts.counter
      description: The download counts per user.
      type: number
  - arguments:
    - description: Sample sha256 IDs. Comma separated values.
      isArray: true
      name: samples
      required: true
    description: 'Schedule samples for download, which returns a request ID. Use the
      request ID in the cs-malquery-get-request, to check the status of the operation.
      When the request status is “done”, use the cs-malquery-sample-fetch to download
      the results as a password-protected archive. The password to extract results
      from the archive: infected'' '
    name: cs-malquery-samples-multidownload
    outputs:
    - contextPath: Malquery.Request_ID
      description: The request ID.
      type: String
    - contextPath: Malquery.Status
      description: The request status.
      type: String
  - arguments:
    - description: The SHA256 file.
      name: file_id
      required: true
    description: Download a file indexed by MalQuery. Specify the file using its SHA256.
      Only one file is supported.
    name: cs-malquery-file-download
    outputs:
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.EntryID
      description: The Entry ID.
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The type of the file.
      type: String
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: String
  - arguments:
    - description: Identifier of a MalQuery request.
      name: request_id
      required: true
    description: Fetches a zip archive file using the password, "infected" containing
      the samples. Use this after the cs-malquery-samples-multidownload request has
      finished processing.
    name: cs-malquery-sample-fetch
    outputs:
    - contextPath: File.SHA256
      description: THe SHA256 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.EntryID
      description: The entry ID.
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The type of the file.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
  - arguments:
    - description: The SHA256 of the files. Comma separated values.
      isArray: true
      name: file
      required: true
    description: Retrieves indexed files metadata by their hash.
    name: file
    outputs:
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: File.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: Malquery.File.family
      description: The malware family of the file. For example, StoneDrill.
      type: String
    - contextPath: Malquery.File.filesize
      description: The size of the file.
      type: String
    - contextPath: Malquery.File.filetype
      description: The type of the file.
      type: String
    - contextPath: Malquery.File.first_seen
      description: The date when the file was first seen.
      type: String
    - contextPath: Malquery.File.label
      description: The label of the file.
      type: String
    - contextPath: Malquery.File.md5
      description: The MD5 hash of the file.
      type: String
    - contextPath: Malquery.File.sha1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: Malquery.File.sha256
      description: The SHA256 hash of the file.
      type: String
  dockerimage: demisto/python3:3.8.3.9324
  runonce: false
  script: |2

      # noqa: E402 lgtm [py/polluting-import]
      # noqa: E402 lgtm [py/polluting-import]

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # CONSTANTS
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    VENDOR_NAME = 'CrowdStrikeMalquery'
    DBOT_SCORE = {
        'unknown': 0,
        'clean': 1,
        'unwanted': 2,
        'malware': 3,
        'malicious': 3,
    }

    # Note: True life time of token is actually 30 mins
    TOKEN_LIFE_TIME = 28


    def get_passed_mins(start_time, end_time_str, tz=None):
        """
            Returns the time passed in mins
            :param start_time: Start time in datetime
            :param end_time_str: End time in str
            :return: The passed mins in int
        """
        time_delta = start_time - datetime.fromtimestamp(end_time_str, tz)
        return time_delta.seconds / 60


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, base_url, verify, proxy, client_id, client_secret):
            super().__init__(base_url=base_url, verify=verify, proxy=proxy)
            self.client_id = client_id,
            self.client_secret = client_secret

        def http_request(self, *args, headers=None, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
            if headers:
                default_headers.update(headers)

            return super()._http_request(*args, headers=default_headers, **kwargs)  # type: ignore[misc]

        def get_access_token(self):
            """
               Obtains access and refresh token from server.
               Access token is used and stored in the integration context until expiration time.
               After expiration, new refresh token and access token are obtained and stored in the
               integration context.

               Returns:
                   str: Access token that will be added to authorization header.
           """
            now = datetime.now()
            integration_context = demisto.getIntegrationContext()[0] \
                if isinstance(demisto.getIntegrationContext(), list) else demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            valid_until = integration_context.get('valid_until')
            if access_token:
                if get_passed_mins(now, valid_until) >= TOKEN_LIFE_TIME:
                    # token expired
                    access_token = self.get_token_request()
                    integration_context = {'access_token': access_token, 'valid_until': date_to_timestamp(now) / 1000}
                    demisto.setIntegrationContext(integration_context)
                return access_token
            else:
                # there's no token
                access_token = self.get_token_request()
                integration_context = {'access_token': access_token,
                                       'valid_until': date_to_timestamp(now) / 1000},
                demisto.setIntegrationContext(integration_context)
                return access_token

        def get_token_request(self):
            """
                Sends token request

                :rtype ``str``
                :return: Access token
            """
            body = {
                'client_id': self.client_id,
                'client_secret': self.client_secret
            }
            headers = {
                'accept': 'application/json',
                'Content-Type': 'application/x-www-form-urlencoded',
            }
            token_response = self._http_request(method='POST', full_url='https://api.crowdstrike.com/oauth2/token',
                                                url_suffix='', data=body, headers=headers)
            if not token_response:
                err_msg = 'Authorization Error: User has no authorization to create a token.' \
                          ' Please make sure you entered the credentials correctly.'
                raise Exception(err_msg)
            return token_response.get('access_token')

        def exact_search(self, body):
            return self.http_request(method="POST", url_suffix='/queries/exact-search/v1', json_data=body)

        def fuzzy_search(self, body):
            return self.http_request(method="POST", url_suffix='/combined/fuzzy-search/v1', json_data=body, timeout=40)

        def hunt(self, body):
            return self.http_request(method="POST", url_suffix='/queries/hunt/v1', json_data=body)

        def get_request(self, request_id):
            params = {'ids': request_id}
            return self.http_request(method="GET", url_suffix='/entities/requests/v1', params=params)

        def get_quotas(self):
            return self.http_request(method="GET", url_suffix='/aggregates/quotas/v1')

        def file_download(self, file_id):
            headers = {"accept": "application/octet-stream"}
            params = {'ids': file_id}
            return self.http_request(method="GET", url_suffix='/entities/download-files/v1', headers=headers, params=params,
                                     resp_type="response")

        def samples_multidownload(self, body):
            return self.http_request(method="POST", url_suffix='/entities/samples-multidownload/v1', json_data=body)

        def fetch_samples(self, request_id):
            headers = {"accept": "application/zip"}
            params = {'ids': request_id}
            return self.http_request(method="GET", url_suffix='/entities/samples-fetch/v1', headers=headers, params=params,
                                     resp_type="response")

        def get_files_metadata(self, files_ids):
            params = {'ids': files_ids}
            return self.http_request(method="GET", url_suffix='/entities/metadata/v1', params=params)


    def test_module(client: Client, args: dict):
        """
        Returning 'ok' indicates that an access token was obtained successfully. Connection to the service is successful.

        Args:
            client:  Client

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        try:
            client.get_access_token()
        except Exception as e:
            raise DemistoException(
                f"Test failed. Please check your parameters. \n {e}")
        return 'ok'


    def exact_search_command(client: Client, args: dict) -> CommandResults:
        pattern_names = ['hex', 'ascii', 'wide']
        patterns = [
            {
                "type": key,
                "value": args[key]
            } for key in pattern_names if args.get(key)
        ]

        # must provide a pattern (hex, ascii ot wide string)
        if not patterns:
            raise DemistoException("You must provide a query to search in one of the following patterns: Hex, ASCII, "
                                   "Wide string")

        # dates format: YYYY/MM/DD
        query_filters = assign_params(limit=int(args.get('limit', '100')),
                                      filter_meta=argToList(args.get('filter_meta')),
                                      filter_filetypes=argToList(args.get('file_types')),
                                      max_size=args.get('max_size'),
                                      min_size=args.get('min_size'),
                                      max_date=args.get('max_date'),
                                      min_date=args.get('min_date'))
        body = {"options": query_filters, "patterns": patterns}
        raw_response = client.exact_search(body)
        entry_context = {"Request_ID": raw_response.get('meta', {}).get('reqid')}

        human_readable = tableToMarkdown('Search Result', entry_context, removeNull=True)

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery',
            outputs_key_field='Request_ID',
            outputs=entry_context,
            raw_response=raw_response)


    def fuzzy_search_command(client: Client, args: dict) -> CommandResults:
        pattern_names = ['hex', 'ascii', 'wide']
        patterns = [
            {
                "type": key,
                "value": args[key]
            } for key in pattern_names if args.get(key)
        ]
        # must provide a pattern (hex, ascii ot wide string)
        if not patterns:
            raise DemistoException("You must provide a query to search in the following patterns: Hex, ASCII, Wide string")
        query_filters = assign_params(limit=int(args.get('limit', '100')),
                                      filter_meta=argToList(args.get('filter_meta')))
        body = {"options": query_filters, "patterns": patterns}
        raw_response = client.fuzzy_search(body)
        resources_found = raw_response.get('resources', {})
        human_readable = tableToMarkdown('Fuzzy Search Result', resources_found, removeNull=True)

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery.File(val.md5 && val.md5 == obj.md5 || val.sha256 && val.sha256 == obj.sha256)',
            outputs_key_field='',
            outputs=resources_found,
            raw_response=raw_response)


    def hunt_command(client: Client, args: dict) -> CommandResults:
        yara_rule = args.get('yara_rule')
        yar_file_entry_id = args.get('yar_file_entry_id')
        if not (yara_rule or yar_file_entry_id):
            raise DemistoException("You must provide either a YARA rule or a YAR file in order to execute the HUNT command")

        if yar_file_entry_id:
            file_path = demisto.getFilePath(yar_file_entry_id).get("path")
            with open(file_path, "rb") as file:
                yara_rule = file.read().decode("utf-8")

        # dates format: YYYY/MM/DD
        query_filters = assign_params(limit=int(args.get('limit', '100')),
                                      filter_meta=argToList(args.get('filter_meta')),
                                      filter_filetypes=argToList(args.get('file_types')),
                                      max_size=args.get('max_size'),
                                      min_size=args.get('min_size'),
                                      max_date=args.get('max_date'),
                                      min_date=args.get('min_date'))
        body = {"options": query_filters, "yara_rule": yara_rule}
        raw_response = client.hunt(body)
        entry_context = {"Request_ID": raw_response.get('meta', {}).get('reqid')}
        human_readable = tableToMarkdown('Search Result', entry_context, removeNull=True)

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery',
            outputs_key_field='Request_ID',
            outputs=entry_context,
            raw_response=raw_response)


    def get_request_command(client: Client, args: dict) -> CommandResults:
        request_id = args.get('request_id')
        raw_response = client.get_request(request_id)
        resources = raw_response.get('resources')
        status = raw_response.get('meta', {}).get('status')

        # Possible values: inprogress, failed, done
        if status != 'done':
            entry_context = {
                "Request_ID": request_id,
                "Status": status
            }
            human_readable = tableToMarkdown('Request Status:', entry_context, removeNull=True)
        else:
            entry_context = {
                "Request_ID": request_id,
                "Status": status,
                "File": resources if resources else None
            }
            human_readable = tableToMarkdown(f'Search Result for request: {request_id}', resources, removeNull=True)

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery',
            outputs_key_field='Request_ID',
            outputs=entry_context,
            raw_response=raw_response)


    def get_file_metadata_command(client: Client, args: dict):
        files_ids = argToList(args.get('file'))
        raw_response = client.get_files_metadata(files_ids)
        files = raw_response.get('resources', [])
        human_readable = ''
        file_indicator_list = []

        for file in files:
            file_label = file.get('label')
            sha256 = file.get('sha256')
            dbot_score = Common.DBotScore(
                indicator=sha256,
                indicator_type=DBotScoreType.FILE,
                integration_name=VENDOR_NAME,
                score=DBOT_SCORE[file_label]
            )
            file_entry = Common.File(sha256=sha256, dbot_score=dbot_score)
            table_name = f'{VENDOR_NAME} File reputation for: {sha256}'
            md = tableToMarkdown(table_name, file, removeNull=True)
            human_readable += md
            file_indicator_list.append(file_entry)

        command_results = CommandResults(
            outputs_prefix='Malquery.File',
            outputs_key_field='sha256',
            outputs=files,
            readable_output=human_readable,
            raw_response=raw_response,
            indicators=file_indicator_list)

        return command_results


    def file_download_command(client: Client, args: dict):
        file_id = args.get('file_id')
        raw_response = client.file_download(file_id)
        try:
            content = raw_response.content
        except Exception as e:
            raise DemistoException(
                f"Failed to load file data. \n {e}")

        return fileResult(file_id, content)


    # Malquery counts the download as the number of sha256 passed to the endpoint and not as a single download.
    def samples_multidownload_command(client: Client, args: dict) -> CommandResults:
        samples = argToList(args.get('samples'))
        body = {"samples": samples}
        raw_response = client.samples_multidownload(body)
        entry_context = {"Request_ID": raw_response.get('meta', {}).get('reqid')}
        human_readable = tableToMarkdown('Samples Multidownload Request', entry_context, removeNull=True)

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery',
            outputs_key_field='Request_ID',
            outputs=entry_context,
            raw_response=raw_response)


    def samples_fetch_command(client: Client, args: dict):
        request_id = args.get('request_id')
        raw_response = client.fetch_samples(request_id)
        try:
            content = raw_response.content
            return fileResult(request_id, content)
        except DemistoException as e:
            if str(e).find('Could not find sample archive'):
                return 'Could not find sample archive, The file is not indexed by MalQuery.'
            else:
                raise


    def get_ratelimit_command(client: Client, args: dict) -> CommandResults:
        raw_response = client.get_quotas()
        meta = raw_response.get('meta', {})
        headers = ['hunt_count', 'download_count', 'monitor_count', 'hunt_limit', 'download_limit', 'monitor_limit',
                   'refresh_time', 'days_left']
        human_readable = tableToMarkdown('Quota Data', meta, headers=headers, removeNull=True)
        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='Malquery.Quota',
            outputs_key_field='refresh_time',
            outputs=meta,
            raw_response=raw_response)


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        client_id: str = params.get('client_id')
        client_secret: str = params.get('client_secret')
        base_url: str = urljoin(params.get('base_url', '').rstrip('/'), '/malquery')
        verify_certificate: bool = not params.get('insecure', False)
        proxy: bool = params.get('proxy', False)

        commands = {
            'test-module': test_module,
            'cs-malquery-exact-search': exact_search_command,
            'cs-malquery-fuzzy-search': fuzzy_search_command,
            'cs-malquery-hunt': hunt_command,
            'cs-malquery-get-request': get_request_command,
            'file': get_file_metadata_command,
            'cs-malquery-file-download': file_download_command,
            'cs-malquery-samples-multidownload': samples_multidownload_command,
            'cs-malquery-sample-fetch': samples_fetch_command,
            'cs-malquery-get-ratelimit': get_ratelimit_command,

        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                client_id=client_id,
                client_secret=client_secret,
                proxy=proxy)

            if command in commands:
                return_results(commands[command](client, demisto.args()))

        # Log exceptions
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
system: true
