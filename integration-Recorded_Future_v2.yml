category: Data Enrichment & Threat Intelligence
commonfields:
  id: Recorded Future v2
  version: -1
configuration:
- defaultvalue: https://api.recordedfuture.com/gw/xsoar/
  display: Server URL (e.g., https://api.recordedfuture.com/gw/xsoar/)
  name: server_url
  required: true
  type: 0
- display: API Token
  name: token
  required: true
  type: 4
- defaultvalue: "65"
  display: File Threshold. Minimum risk score from Recorded Future to consider the
    file malicious.
  name: file_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: CVE Threshold. Minimum risk score from Recorded Future to consider the
    CVE malicious.
  name: cve_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: IP Threshold. Minimum risk score from RF to consider the IP malicious.
  name: ip_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: Domain Threshold. Minimum risk score from Recorded Future to consider the
    domain malicious.
  name: domain_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: URL Threshold. Minimum risk score from Recorded Future to consider the
    URL malicious.
  name: url_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: Vulnerability Threshold. Minimum risk score from Recorded Future to consider
    the vulnerability critical.
  name: vulnerability_threshold
  required: false
  type: 0
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Rule names to fetch alerts by, separated by semicolon. If empty, all alerts
    will be fetched
  name: rule_names
  required: false
  type: 12
- defaultvalue: 24 hours
  display: First fetch time (<number> <time unit>, e.g., 12 hours, 7 days, 3 months,
    1 year)
  name: first_fetch
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "50"
  display: Maximum number of incidents per fetch
  name: max_fetch
  required: false
  type: 0
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.2.1
    packID: RecordedFuture
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Unique threat intel technology that automatically serves up relevant
  insights in real time.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: Recorded Future
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [support@recordedfuture.com](mailto:support@recordedfuture.com)
  - **URL**: [https://www.recordedfuture.com/support/demisto-integration/](https://www.recordedfuture.com/support/demisto-integration/)
  ***
  ## Information
  A valid API Token for XSOAR from Recorded Future needed to fetch information.
  [Get help with Recorded Future for Cortex XSOAR](https://www.recordedfuture.com/support/demisto-integration/).

  ---

  ## Configuration
  | Parameter                        | Description                                                       |
  |----------------------------------|-------------------------------------------------------------------|
  | Server URL                       | The URL to the Recorded Future ConnectAPI                         |
  | API Token                        | Valid API Token from Recorded Future                              |
  | File/IP/Domain/URL/CVE Threshold | Minimum risk score from Recorded Future needed to mark IOC as malicious when doing reputation or intelligence lookups  |
  | unsecure                         | Trust any certificate \(unsecure\)                                |
  | proxy                            | Use system proxy settings                                         |

  ---

  ## Available Actions
  * Reputation actions
      * Using the new Recorded Future SOAR Enrichment API.
      * Available actions: ip, domain, url, file(hashes), cve.
  * Intelligence action
      * Fetches full information for the entity.
      * Supports IPs, Domains, URLs, Files(hashes), vulnerabilities(cve).
  * Alert actions
      * Fetch alerting rules defined at Recorded Future.
      * Fetch alert summaries from one or more alerting rules.
      * Set alert status in Recorded Future
      * Add note to alert in Recorded Future
  * Threat assessment action
      * Takes a context, such as phishing or malware and one or more IOC as input.
      * Outputs a verdict (true/false) and related evidence (risk rules) for this context.

  Copyright 2021 Recorded Future, Inc.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/recorded-future-v2)
display: Recorded Future v2 (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAC6NJREFUeAHtmH9wVNUVx+97+3Y3i0lIgOFnQiCEgEZQxB8EZyQwSrFVK85UOk5bq7VUpyJii7VOtRlFbRSdsSgF/QNELfUHrTqOtaAmtGIFxaFgtEACwfyAqCGJZLPJ7r73+jkvu0s2pomMg7Qz983c3HvPOff8+J5zf2yU0p9GQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQEgZvfn6qWvJunwfj/QMA8ITdv3j7RDAQ2+6zQOrXsndAJrdXCpwSBwRN8YUWWKinP9Lwz3FGGofJdQ01RbXGPNvSmf+SqJfuDp8R7bXRQBIwBJQp/NdTIynlJ+cxu90jtVWrRkjMMZe9QpqpzbfecQNweHQ8GXlRuvNLJnrFUlRtOf/oKCwuHDhkyJEN4XV1dTjAYbK+uro72J/tN0AoKCmZgJ+PQoUP/PAF7PtZd5PP5Gg8cOLCv97opU6ZkEVPIcZwUnhJnTU1NG3Kx3rLf9Nga0GDQPxL+bGUbMeUfOUoZpq1cu2dJlPQGY6cbVrDEicZt1fJXP4zufvRl2ra9KRKJTAQA4ZudnZ3tEyZMWFNXV7eeudvPmpNKsixrMT6NwciVJ2AoZJrmPbRXWVORXFdSUpJJMtfGYrFZ0Lz4Xdc1+KLEuJwY/5aUTfZFRUWT4F8AJn9paGiIJOknox84waYl4MeV4cY944GAIsWG48RJ5qekJstVjpfwHn7/HvoJRgLaGI/H/wxAAcQW0j82adKkQ7W1tW/1v+ykUmWnpXbb17FEHBJfIbG9StE8Q3J9og+aTSGl7fSknWg0Wgrvt5wGldBOYYKTHkkfsvwq3FKrglnPGK7/oLt6a6daduVXAgkQvGA5st5PqHxv4sSJ8wlyLvNTkWAp3BM6OfLy8qSS+11DUh0SWsNu3JGIb8AOWdETpSC8HT+g8NdkfmkHFxUtCR4bErSad68Mp+n2B0y1atYXJRvm3+iPbI7uVMpRzhVfeqSN59FVOCp+rKp87kC7WsCyAcbb/hxZQYK9yO/3j6a63+NY+3fSNsfc6IyMjNnMg/B2Ju8/1mRTIHPQkQH97wcPHmyWNXL8UVBd0IV/LtfC23v37j0IvYT5Wey0XdDS3gqcJPmBQGA2azpFFzbaE/Yt3g+z8GtMd3f3HvievwnegB0FXMAOtSjqWhEkjgz0TMXOR+FwWOxn4ufl48ePb/rkk0+2FxcXj+WYb03GIUc/V9kk5tX4novvufjQDhZlYHVg3759740bN244b5s56LGIq4rTkGM1/UtP8FkrxtUagScQyVVF9/5QOdy9ya/ViKu3FkzZ44TWuc53G1VlzXVqk3U84OE7Yr6lH1xx2B+qOBy23ywpr76turwkmlwOOPmTJ08+XaqXQK6CPp7+NQLPwbm1OFlM30R/F0HfR9BP5efnn4fcBgKzWN8B7zSCXUSAR2nP0sZAj0K30fMTCmM7tLugnUkOTfTFGH8G2OdCX0U7iv1WaMPpd4tv8C5B9iF8+RT5LHjLsPvT+vr6OngPIHIt9puQ/4I2gXY8ZlHQ88mlW8QjrJT14k81CbkVeyPKy8uvpTnonwr9eXQtFBlaLglfjO1G7DRj+xFUvU5bKSopgnORfxydF6P7W9zzd7CmhfU59GvwMUIBPYnebnoXPXdAW4zfyVNS1PAe7v256hzD8n+bh1OpCvnPVDb3b/JryIizZ2e4oUApj66rVKB7lFKB4zuBIFxTXeKEMqc6VEB19FhuYqkYdwhgMY79kX4HDl3N+AaqU460GwmkCPo8ds53EL0f/t3Tp0/PA6Tb4TXwGJkNfza8HzGvZ+3dNIvdNof1pQD5MfSVpaWl8ts8A14BtOXov5AdswfaCkDaSLWfDyA/gy9HpDFt2rRchveydhM7bT40uTI6WXMLoMuO/gHtF9iWxD1COw1+2ifgQpAEL2T8KLpWICeFZ0EL8GvBu8bg+aAFE73c0w3E9z18vJqdWktsolveJ97HXDZfgN7Avg+9k4npZRJ/PmseY+398D+mqMvYuXORe5+C+QNXybAeDT1/03dwZ/Nm5YxZbpq+HMf4/A1OEZLovRmUKowEVGbra1ZH4N64pQ6rxpo6ZYXP4nLu0VRWafmjsVUqcszkJHvHDrz+WcKQgXMGPyMepfqew5Gnobfg2EvCB4QSWjvBn4dzPoLJBODstra2CYCRj8hzR44cSep6lx0cRH4GAW5ER4PoYMdvoFtNlY+EJ4Bv4QR4U3gAko/tISIP2B2QPuRI3oofI1paWkbBG8nYxvYCbCtsdzMvoC+mgOoB9VV56Y4dO3Yzsh/jZwIQ0c49Y9uSQB6ezmqOzMfw28VOmNNKEiq+pL6+c/A4vkF6iqS3vFc4shj8fNjZj3/rmpubw/KzkziLoB0QvxnLGyCO/tNJchZLjiaNpie4ZpVYXJmyWlJ+fIefxm6ftf2LuHp8da6yIq3qFVstNbzq9JRNi/i6V82VV+PPk8p79QLA51RaPUCtALyXcPJidixFpCTufIK4HBkfjkrlV5Cs/ZmZmXI0Hz9FEKbafQAthZGisy7O3CWJHviskUR6n+wYBvLbO3W0QrJZ4/GRNVk7C9pYsU+Te+w56AW0OH6lQJe5t+jLfwSHyLZt244lWVLU6HK5S90XXnhB/PUMoiOFWe8x64Segj4hbyRkmBqd3L/elYle2TQOPDaYtwOlmCxot4RCocNJH6RPT3BvTt+xa8XUmSvyDTNc1Wa5+9UHZZdRWimH+or3neOAB35TU1Mlya3C4TuRqaTJz4S9/NNhSe818ihhjY3To3vTeYxE2Z1hqrkgSadgJiIbZ0d0CBKMUyCSuGOSuI6OjnHI8zbkPw+x2AjpqfZuxCXZT2F/k9CSH/YXwRuBrhxobYzlqMoR9UmZPn3KptDxrwO9JevXr5djt4t1crr4uW46KEQR8eGHlzB2ZTenSgR5ObG8D9/ymEv1dwlBYmLu2eBkiZJs2bWvc7pU9Kzo/+9XTzAFqVxnpGG5hUTI7+DskOIw7l9tGlWckmQljzab4B8A+Ld4QFzBMfM0403cefII2kzwk5EvJrFLif9lxsvgtTL/DP4Ckvs4/RrmvycJchTJf4tuJ/gndu/e/SlAyX/MUj8/sLsP2a3QVsIbw9opjC+DvoWk1qP7NYCq4JiXZB7B/nzkd4DhFvwKw3sCOxvpF7BuOryN9KkvAbpcG2lYYudFZBciuBa779AvRbaSR9Ah9GXBG0JhPojdrYxfZv06ZB6SWJGTR9cvoT3f2Nh4FJoUSUbClmKTdELbwLrb0CVvnI/wdQ4y7cOGDavYuXOnVzjM+zyyhNL765YHhBGkBVSMBNvKcW3H7Xl8BV1lwLfEtknC+/+4IyIA9ycC/jApQZK24fzvqFKL8dvwrsHZ8cx/jcyltB08emLIPCIN3kKCuIm+DeAPkphnkbkV3jwCWwQYD3Ef3yf6sbWZVilj+aDL7lkGbQv99TS5BnhnmPIfpjhH/h3M12L7+7Tl0IZiaxeJaGLN9ciFsXEDMrsY3wX/X7TUl52dLfG9Qgy7UkQG2N1O92NaDvquS8jIKRWHJ7ISz1B0Xwovl3ifxsZt0C6kyK5h/CQnUjlysN090J9nnPqnCA+th5n/BrmLE7gVI/c2yU1dRfAH+W9O3rKQOXzUfZzytmPk3qm6ms/mlY3jZp3rtM5U864MmP6slcqNbXMePnuNKPw6H/eVvDpTP6166fLNnDnT7F2ZCZ6cDvJOSAuq17q0YVlZmVVVVfXf7lETG75+bIgOOX2+ko00g4nJIHb7LjmhmGTxALgNkuC+ps+45wIzI+NdV7n1rhE5R+0s/7yviJ7/byGQdm8M6pqvc5/r+N8wXGOvazW1DyqvBTQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AROCkI/Adox/h1F7lx8wAAAABJRU5ErkJggg==
name: Recorded Future v2
script:
  commands:
  - arguments:
    - default: true
      description: The domain for which to get the reputation.
      isArray: true
      name: domain
      required: true
    description: Gets a quick indicator of the risk associated with a domain.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious Domains, the reason that the vendor made the decision
      type: string
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: RecordedFuture.Domain.riskScore
      description: Recorded Future domain risk score
      type: number
    - contextPath: RecordedFuture.Domain.riskLevel
      description: Recorded Future domain risk level
      type: string
    - contextPath: RecordedFuture.Domain.Evidence.rule
      description: Recorded Future risk rule name
      type: string
    - contextPath: RecordedFuture.Domain.Evidence.mitigation
      description: Recorded Future risk rule mitigation
      type: string
    - contextPath: RecordedFuture.Domain.Evidence.description
      description: Recorded Future risk rule description
      type: string
    - contextPath: RecordedFuture.Domain.Evidence.timestamp
      description: Recorded Future risk rule timestamp
      type: date
    - contextPath: RecordedFuture.Domain.Evidence.level
      description: Recorded Future risk rule level
      type: number
    - contextPath: RecordedFuture.Domain.Evidence.ruleid
      description: Recorded Future risk rule ID
      type: string
    - contextPath: RecordedFuture.Domain.name
      description: Domain name
      type: string
    - contextPath: RecordedFuture.Domain.maxRules
      description: Maximum number of Recorded Future domain risk rules
      type: number
    - contextPath: RecordedFuture.Domain.rules
      description: All the rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.Domain.ruleCount
      description: Number of triggered Recorded Future Domain Risk Rules
      type: number
  - arguments:
    - default: true
      description: IP address for which to get the reputation
      isArray: true
      name: ip
      required: true
    description: Gets a quick indicator of the risk associated with an IP address.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: RecordedFuture.IP.riskScore
      description: Recorded Future IP risk score
      type: number
    - contextPath: RecordedFuture.IP.riskLevel
      description: Recorded Future IP Risk Level
      type: string
    - contextPath: RecordedFuture.IP.Evidence.rule
      description: Recorded Future risk rule name
      type: string
    - contextPath: RecordedFuture.IP.Evidence.mitigation
      description: Recorded Future risk rule mitigation
      type: string
    - contextPath: RecordedFuture.IP.Evidence.description
      description: Recorded Future risk rule description
      type: string
    - contextPath: RecordedFuture.IP.Evidence.timestamp
      description: Recorded Future risk rule timestamp
      type: date
    - contextPath: RecordedFuture.IP.Evidence.level
      description: Recorded Future risk rule level
      type: number
    - contextPath: RecordedFuture.IP.Evidence.ruleid
      description: Recorded Future risk rule ID
      type: string
    - contextPath: RecordedFuture.IP.name
      description: IP address
      type: string
    - contextPath: RecordedFuture.IP.maxRules
      description: Maximum number of Recorded Future IP risk rules
      type: number
    - contextPath: RecordedFuture.IP.rules
      description: All the rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.IP.ruleCount
      description: Number of triggered Recorded Future IP risk rules
      type: number
  - arguments:
    - default: true
      description: File hash for which to check the reputation. Can be an MD5, SHA1,
        SHA256, SHA512, CRC32 or CTPH
      isArray: true
      name: file
      required: true
    description: Gets a quick indicator of the risk associated with a file.
    name: file
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: File.SHA256
      description: SHA-256 hash of the file
      type: string
    - contextPath: File.SHA512
      description: SHA-512 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA-1 hash of the file
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.CRC32
      description: CRC32 hash of the file
      type: string
    - contextPath: File.CTPH
      description: CTPH hash of the file
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision
      type: string
    - contextPath: RecordedFuture.File.riskScore
      description: Recorded Future hash risk score
      type: number
    - contextPath: RecordedFuture.File.riskLevel
      description: Recorded Future hash risk level
      type: string
    - contextPath: RecordedFuture.File.Evidence.rule
      description: Recorded Future risk rule name
      type: string
    - contextPath: RecordedFuture.File.Evidence.mitigation
      description: Recorded Future risk rule mitigation
      type: string
    - contextPath: RecordedFuture.File.Evidence.description
      description: Recorded Future risk rule description
      type: string
    - contextPath: RecordedFuture.File.Evidence.timestamp
      description: Recorded Future risk rule timestamp
      type: date
    - contextPath: RecordedFuture.File.Evidence.level
      description: Recorded Future risk rule level
      type: number
    - contextPath: RecordedFuture.File.Evidence.ruleid
      description: Recorded Future risk rule ID
      type: string
    - contextPath: RecordedFuture.File.name
      description: File name
      type: string
    - contextPath: RecordedFuture.File.maxRules
      description: Maximum number of Recorded Future hash risk rules
      type: number
    - contextPath: RecordedFuture.File.rules
      description: All the rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.File.ruleCount
      description: Number of triggered Recorded Future Hash Risk Rules
      type: number
  - arguments:
    - default: true
      description: CVE for which to get the reputation.
      isArray: true
      name: cve
      required: true
    description: Gets a quick indicator of the risk associated with a CVE.
    name: cve
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: CVE.ID
      description: Vulnerability name
      type: string
    - contextPath: RecordedFuture.CVE.riskScore
      description: Recorded Future vulnerability risk score
      type: number
    - contextPath: RecordedFuture.CVE.riskLevel
      description: Recorded Future vulnerability risk level
      type: string
    - contextPath: RecordedFuture.CVE.Evidence.rule
      description: Recorded Future risk rule name
      type: string
    - contextPath: RecordedFuture.CVE.Evidence.mitigation
      description: Recorded Future risk rule mitigation
      type: string
    - contextPath: RecordedFuture.CVE.Evidence.description
      description: Recorded Future risk rule description
      type: string
    - contextPath: RecordedFuture.CVE.Evidence.timestamp
      description: Recorded Future risk rule timestamp
      type: date
    - contextPath: RecordedFuture.CVE.Evidence.level
      description: Recorded Future risk rule level
      type: number
    - contextPath: RecordedFuture.CVE.Evidence.ruleid
      description: Recorded Future risk rule ID
      type: string
    - contextPath: RecordedFuture.CVE.name
      description: CVE name
      type: string
    - contextPath: RecordedFuture.CVE.maxRules
      description: Maximum number of Recorded Future Vulnerability risk rules.
      type: number
    - contextPath: RecordedFuture.CVE.rules
      description: All the rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.CVE.ruleCount
      description: Number of triggered Recorded Future Vulnerability Risk Rules
      type: number
  - arguments:
    - default: true
      description: URL for which to get the reputation.
      isArray: true
      name: url
      required: true
    description: Gets a quick indicator of the risk associated with a URL.
    name: url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision
      type: string
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: RecordedFuture.URL.riskScore
      description: Recorded Future URL risk score
      type: number
    - contextPath: RecordedFuture.URL.riskLevel
      description: Recorded Future URL risk level
      type: string
    - contextPath: RecordedFuture.URL.Evidence.rule
      description: Recorded Risk rule name
      type: string
    - contextPath: RecordedFuture.URL.Evidence.mitigation
      description: Recorded Risk rule mitigation
      type: string
    - contextPath: RecordedFuture.URL.Evidence.description
      description: Recorded Risk rule description
      type: string
    - contextPath: RecordedFuture.URL.Evidence.timestamp
      description: Recorded Risk rule timestamp
      type: date
    - contextPath: RecordedFuture.URL.Evidence.level
      description: Recorded Risk rule Level
      type: number
    - contextPath: RecordedFuture.URL.Evidence.ruleid
      description: Recorded Risk rule ID
      type: string
    - contextPath: RecordedFuture.URL.name
      description: URL name
      type: string
    - contextPath: RecordedFuture.URL.maxRules
      description: Maximum number of Recorded Future URL risk rules.
      type: number
    - contextPath: RecordedFuture.URL.rules
      description: All the rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.URL.ruleCount
      description: Number of triggered Recorded Future URL Risk Rules
      type: number
  - arguments:
    - auto: PREDEFINED
      description: Context to use for the assessment. This is used by Recorded Future
        to calculate the relevant score and verdict. Can be "c2", "malware", or "phishing".
      name: context
      predefined:
      - c2
      - malware
      - phishing
      required: true
    - description: IP addresses to check if they are related to the selected context.
      isArray: true
      name: ip
    - description: Domains to check if they are related to the selected context.
      isArray: true
      name: domain
    - description: File hashes to check if they are related to the selected context.
      isArray: true
      name: file
    - description: URLs to check if they are related to the selected context.
      isArray: true
      name: url
    - description: CVEs to check if they are related to the selected context.
      isArray: true
      name: cve
    - auto: PREDEFINED
      description: Will filter out entities that have zero as score
      name: filter
      predefined:
      - "yes"
      - "no"
    description: Get an indicator of the risk based on context.
    name: recordedfuture-threat-assessment
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.SHA256
      description: SHA-256 hash of the file
      type: string
    - contextPath: File.SHA512
      description: SHA-512 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA-1 hash of the file
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.CRC32
      description: CRC32 hash of the file
      type: string
    - contextPath: File.CTPH
      description: CTPH hash of the file
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.ASN
      description: ASN
      type: string
    - contextPath: IP.Geo.Country
      description: IP address geolocation country
      type: string
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: CVE.ID
      description: Vulnerability name
      type: string
    - contextPath: RecordedFuture.verdict
      description: Recorded Future verdict
      type: boolean
    - contextPath: RecordedFuture.context
      description: Threat assessment context
      type: string
    - contextPath: RecordedFuture.riskScore
      description: Recorded Future maximum risk score
      type: number
    - contextPath: RecordedFuture.Entities.id
      description: Entity ID
      type: string
    - contextPath: RecordedFuture.Entities.name
      description: Entity name
      type: string
    - contextPath: RecordedFuture.Entities.type
      description: Entity type
      type: string
    - contextPath: RecordedFuture.Entities.score
      description: Entity score
      type: string
    - contextPath: RecordedFuture.Entities.context
      description: Contains the current context if there is evidence
      type: string
    - contextPath: RecordedFuture.Entities.Evidence.ruleid
      description: Recorded Future Risk Rule ID
      type: string
    - contextPath: RecordedFuture.Entities.Evidence.timestamp
      description: Recorded Future evidence timestamp
      type: date
    - contextPath: RecordedFuture.Entities.Evidence.mitigation
      description: Recorded Future evidence mitigation
      type: string
    - contextPath: RecordedFuture.Entities.Evidence.description
      description: Recorded Future evidence description
      type: string
    - contextPath: RecordedFuture.Entities.Evidence.rule
      description: Recorded Future risk rule
      type: string
    - contextPath: RecordedFuture.Entities.Evidence.level
      description: Recorded Future risk rule level
      type: number
  - arguments:
    - description: Rule name to search. Can be a partial name
      name: rule_name
    - defaultValue: "10"
      description: Maximum number of rules to return. Default is 10.
      name: limit
    description: Search for alert rule IDs.
    name: recordedfuture-alert-rules
    outputs:
    - contextPath: RecordedFuture.AlertRule.id
      description: Alert rule ID
      type: string
    - contextPath: RecordedFuture.AlertRule.name
      description: Alert rule name
      type: string
  - arguments:
    - description: Alert rule id
      name: id
      required: true
    description: Get detailed information from vulnerability, typosquat and credential
      alerts
    name: recordedfuture-single-alert
    outputs:
    - contextPath: RecordedFuture.SingleAlert.id
      description: Alert ID
      type: string
    - contextPath: RecordedFuture.SingleAlert.flat_entities.fragment
      description: Fragment of entity
      type: string
    - contextPath: RecordedFuture.SingleAlert.flat_entities.name
      description: Name of entity
      type: string
    - contextPath: RecordedFuture.SingleAlert.flat_entities.type
      description: Type of entity
      type: string
    - contextPath: RecordedFuture.SingleAlert.flat_entities.id
      description: The id of the entity
      type: string
  - arguments:
    - description: Alert rule ID
      name: rule_id
    - defaultValue: "10"
      description: Maximum number of alerts to return. Default is 10.
      name: limit
    - description: Alert triggered time, e.g., "1 hour" or "2 days".
      name: triggered_time
    - description: Alert assignee's email address.
      name: assignee
    - auto: PREDEFINED
      description: Alert review status. Can be "unassigned", "assigned", "actionable",
        "no-action", or "tuning".
      name: status
      predefined:
      - unassigned
      - assigned
      - actionable
      - no-action
      - tuning
    - description: Free text search
      name: freetext
    - description: Alerts from offset
      name: offset
    - auto: PREDEFINED
      description: Alerts sort order
      name: orderby
      predefined:
      - triggered
    - auto: PREDEFINED
      description: The direction by which to sort alerts. Can be "asc" or "desc".
      name: direction
      predefined:
      - asc
      - desc
    description: Gets details on alerts configured and generated by Recorded Future
      by alert rule ID and/or time range.
    name: recordedfuture-alerts
    outputs:
    - contextPath: RecordedFuture.Alert.id
      description: Alert ID
      type: string
    - contextPath: RecordedFuture.Alert.name
      description: Alert name
      type: string
    - contextPath: RecordedFuture.Alert.type
      description: Alert type
      type: string
    - contextPath: RecordedFuture.Alert.triggered
      description: Alert triggered time
      type: date
    - contextPath: RecordedFuture.Alert.status
      description: Alert status
      type: string
    - contextPath: RecordedFuture.Alert.assignee
      description: Alert assignee
      type: string
    - contextPath: RecordedFuture.Alert.rule
      description: Alert rule name
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: All
      description: Depending on what profile you choose you will get different related
        entities matching the given profile
      name: profile
      predefined:
      - All
      - Threat Hunter
      - SecOp Analyst
      - TI Analyst
      - Vulnerability Analyst
    - auto: PREDEFINED
      description: The type of entity for which to fetch context. Should be provided
        with its value in entityValue argument. Can be "domain", "ip", "file", "url",
        or "cve".
      name: entity_type
      predefined:
      - domain
      - ip
      - file
      - url
      - cve
      required: true
    - description: 'The value of the entity for which to fetch context. Should be
        provided with its type in entity_type argument. Supported hash types: MD5,
        SHA1, SHA256, SHA512, CRC32, and CTPH. Vulnerability supports CVEs.'
      name: entity
      required: true
    - auto: PREDEFINED
      description: Whether to fetch related entity data. Can be "yes" or "no".
      name: fetch_related_entities
      predefined:
      - "yes"
      - "no"
      required: true
    - auto: PREDEFINED
      description: Whether risk scores for other IP addresses within the same CIDR
        should be fetched (only for IP intelligence). Can be "yes" or "no".
      name: fetch_riskyCIDRips
      predefined:
      - "no"
      - "yes"
      required: true
    description: Get threat intelligence for an IP, Domain, CVE, URL or File.
    name: recordedfuture-intelligence
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.SHA256
      description: SHA-256 hash of the file
      type: string
    - contextPath: File.SHA512
      description: SHA-512 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA-1 hash of the file
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.CRC32
      description: CRC32 hash of the file
      type: string
    - contextPath: File.CTPH
      description: CTPH hash of the file
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.ASN
      description: ASN
      type: string
    - contextPath: IP.Geo.Country
      description: IP address geolocation country
      type: string
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: CVE.ID
      description: Vulnerability name
      type: string
    - contextPath: RecordedFuture.IP.criticality
      description: Risk criticality
      type: number
    - contextPath: RecordedFuture.IP.criticalityLabel
      description: Risk criticality label
      type: string
    - contextPath: RecordedFuture.IP.riskString
      description: Risk string
      type: string
    - contextPath: RecordedFuture.IP.riskSummary
      description: Risk summary
      type: string
    - contextPath: RecordedFuture.IP.rules
      description: Risk rules
      type: string
    - contextPath: RecordedFuture.Ip.concatRules
      description: All risk rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.IP.score
      description: Risk score
      type: number
    - contextPath: RecordedFuture.IP.firstSeen
      description: Evidence first seen date
      type: date
    - contextPath: RecordedFuture.IP.lastSeen
      description: Evidence last seen date
      type: date
    - contextPath: RecordedFuture.IP.intelCard
      description: Recorded Future intelligence card URL
      type: string
    - contextPath: RecordedFuture.IP.type
      description: Entity type
      type: string
    - contextPath: RecordedFuture.IP.name
      description: Entity
      type: string
    - contextPath: RecordedFuture.IP.id
      description: Recorded Future entity ID
      type: string
    - contextPath: RecordedFuture.IP.location.asn
      description: ASN number
      type: string
    - contextPath: RecordedFuture.IP.location.cidr.id
      description: Recorded Future CIDR ID
      type: string
    - contextPath: RecordedFuture.IP.location.cidr.name
      description: CIDR name
      type: string
    - contextPath: RecordedFuture.IP.location.cidr.type
      description: CIDR type
      type: string
    - contextPath: RecordedFuture.IP.location.location.city
      description: IP address geolocation city
      type: string
    - contextPath: RecordedFuture.IP.location.location.continent
      description: IP address geolocation continent
      type: string
    - contextPath: RecordedFuture.IP.location.location.country
      description: IP address geolocation country
      type: string
    - contextPath: RecordedFuture.IP.location.organization
      description: IP address geolocation organization
      type: string
    - contextPath: RecordedFuture.IP.metrics.type
      description: Recorded Future metrics type
      type: string
    - contextPath: RecordedFuture.IP.metrics.value
      description: Recorded Future metrics value
      type: number
    - contextPath: RecordedFuture.IP.threatLists.description
      description: Recorded Future threat list description
      type: string
    - contextPath: RecordedFuture.IP.threatLists.id
      description: Recorded Future threat list ID
      type: string
    - contextPath: RecordedFuture.IP.threatLists.name
      description: Recorded Future threat list name
      type: string
    - contextPath: RecordedFuture.IP.threatLists.type
      description: Recorded Future threat list type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttacker.count
      description: Recorded Future related attacker count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttacker.id
      description: Recorded Future related attacker ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttacker.name
      description: Recorded Future related attacker name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttacker.type
      description: Recorded Future related attacker type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTarget.count
      description: Recorded Future related target count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTarget.id
      description: Recorded Future related target ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTarget.name
      description: Recorded Future related target name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTarget.type
      description: Recorded Future related target type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedThreatActor.count
      description: Recorded Future related threat actor count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedThreatActor.id
      description: Recorded Future related threat actor ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedThreatActor.name
      description: Recorded Future related threat actor name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedThreatActor.type
      description: Recorded Future related threat actor type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalware.count
      description: Recorded Future related malware count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalware.id
      description: Recorded Future related malware ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalware.name
      description: Recorded Future related malware name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalware.type
      description: Recorded Future related malware type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCyberVulnerability.count
      description: Recorded Future related vulnerability count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCyberVulnerability.id
      description: Recorded Future related vulnerability ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCyberVulnerability.name
      description: Recorded Future related vulnerability name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCyberVulnerability.type
      description: Recorded Future related vulnerability type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedIpAddress.count
      description: Recorded Future related IP address count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedIpAddress.id
      description: Recorded Future related IP address ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedIpAddress.name
      description: Recorded Future related IP address name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedIpAddress.type
      description: Recorded Future related IP address type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedInternetDomainName.count
      description: Recorded Future related domain name count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedInternetDomainName.id
      description: Recorded Future related domain name ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedInternetDomainName.name
      description: Recorded Future related domain name name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedInternetDomainName.type
      description: Recorded Future related domain name type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedProduct.count
      description: Recorded Future related product count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedProduct.id
      description: Recorded Future related product ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedProduct.name
      description: Recorded Future related product name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedProduct.type
      description: Recorded Future related product type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCountries.count
      description: Recorded Future related countries count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCountries.id
      description: Recorded Future related countries ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCountries.name
      description: Recorded Future related countries name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCountries.type
      description: Recorded Future related countries type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedHash.count
      description: Recorded Future related hash count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedHash.id
      description: Recorded Future related hash ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedHash.name
      description: Recorded Future related hash name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedHash.type
      description: Recorded Future related hash type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTechnology.count
      description: Recorded Future related technology count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTechnology.id
      description: Recorded Future related technology ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTechnology.name
      description: Recorded Future related technology name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedTechnology.type
      description: Recorded Future related technology type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedEmailAddress.count
      description: Recorded Future related email address count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedEmailAddress.id
      description: Recorded Future related email address ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedEmailAddress.name
      description: Recorded Future related email address name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedEmailAddress.type
      description: Recorded Future related email address type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttackVector.count
      description: Recorded Future related attack vector count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttackVector.id
      description: Recorded Future related attack vector ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttackVector.name
      description: Recorded Future related attack vector name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedAttackVector.type
      description: Recorded Future related attack vector type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalwareCategory.count
      description: Recorded Future related malware category count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalwareCategory.id
      description: Recorded Future related malware category ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalwareCategory.name
      description: Recorded Future related malware category name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedMalwareCategory.type
      description: Recorded Future related malware category type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedOperations.count
      description: Recorded Future related operations count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedOperations.id
      description: Recorded Future related operations ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedOperations.name
      description: Recorded Future related operations name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedOperations.type
      description: Recorded Future related operations type
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCompany.count
      description: Recorded Future related company count
      type: number
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCompany.id
      description: Recorded Future related company ID
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCompany.name
      description: Recorded Future related company name
      type: string
    - contextPath: RecordedFuture.IP.relatedEntities.RelatedCompany.type
      description: Recorded Future related company type
      type: string
    - contextPath: RecordedFuture.Domain.criticality
      description: Risk criticality
      type: number
    - contextPath: RecordedFuture.Domain.criticalityLabel
      description: Risk criticality label
      type: string
    - contextPath: RecordedFuture.Domain.riskString
      description: Risk string
      type: string
    - contextPath: RecordedFuture.Domain.riskSummary
      description: Risk summary
      type: string
    - contextPath: RecordedFuture.Domain.rules
      description: Risk rules
      type: string
    - contextPath: RecordedFuture.Domain.concatRules
      description: All risk rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.Domain.score
      description: Risk score
      type: number
    - contextPath: RecordedFuture.Domain.firstSeen
      description: Evidence first seen date
      type: date
    - contextPath: RecordedFuture.Domain.lastSeen
      description: Evidence last seen
      type: date
    - contextPath: RecordedFuture.Domain.intelCard
      description: Recorded Future intelligence card URL
      type: string
    - contextPath: RecordedFuture.Domain.type
      description: Entity type
      type: string
    - contextPath: RecordedFuture.Domain.name
      description: Entity
      type: string
    - contextPath: RecordedFuture.Domain.id
      description: Recorded Future entity ID
      type: string
    - contextPath: RecordedFuture.Domain.metrics.type
      description: Recorded Future metrics type
      type: string
    - contextPath: RecordedFuture.Domain.metrics.value
      description: Recorded Future metrics value
      type: number
    - contextPath: RecordedFuture.Domain.threatLists.description
      description: Recorded Future threat list description
      type: string
    - contextPath: RecordedFuture.Domain.threatLists.id
      description: Recorded Future threat list ID
      type: string
    - contextPath: RecordedFuture.Domain.threatLists.name
      description: Recorded Future threat list name
      type: string
    - contextPath: RecordedFuture.Domain.threatLists.type
      description: Recorded Future threat list type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttacker.count
      description: Recorded Future related attacker count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttacker.id
      description: Recorded Future related attacker ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttacker.name
      description: Recorded Future related attacker name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttacker.type
      description: Recorded Future related attacker type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTarget.count
      description: Recorded Future related target count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTarget.id
      description: Recorded Future related target ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTarget.name
      description: Recorded Future related target name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTarget.type
      description: Recorded Future related target type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedThreatActor.count
      description: Recorded Future related threat actor count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedThreatActor.id
      description: Recorded Future related threat actor ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedThreatActor.name
      description: Recorded Future related threat actor name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedThreatActor.type
      description: Recorded Future related threat actor type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalware.count
      description: Recorded Future related malware count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalware.id
      description: Recorded Future related malware ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalware.name
      description: Recorded Future related malware name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalware.type
      description: Recorded Future related malware type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCyberVulnerability.count
      description: Recorded Future related vulnerability count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCyberVulnerability.id
      description: Recorded Future related vulnerability ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCyberVulnerability.name
      description: Recorded Future related vulnerability name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCyberVulnerability.type
      description: Recorded Future related vulnerability type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedIpAddress.count
      description: Recorded Future related IP address count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedIpAddress.id
      description: Recorded Future related IP address ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedIpAddress.name
      description: Recorded Future related IP address name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedIpAddress.type
      description: Recorded Future related IP address type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedInternetDomainName.count
      description: Recorded Future related domain name count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedInternetDomainName.id
      description: Recorded Future related domain name ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedInternetDomainName.name
      description: Recorded Future related domain name name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedInternetDomainName.type
      description: Recorded Future related domain name type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedProduct.count
      description: Recorded Future related product count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedProduct.id
      description: Recorded Future related product ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedProduct.name
      description: Recorded Future related product name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedProduct.type
      description: Recorded Future related product type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCountries.count
      description: Recorded Future related countries count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCountries.id
      description: Recorded Future related countries ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCountries.name
      description: Recorded Future related countries name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCountries.type
      description: Recorded Future related countries type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedHash.count
      description: Recorded Future related hash count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedHash.id
      description: Recorded Future related hash ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedHash.name
      description: Recorded Future related hash name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedHash.type
      description: Recorded Future related hash type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTechnology.count
      description: Recorded Future related technology count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTechnology.id
      description: Recorded Future related technology ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTechnology.name
      description: Recorded Future related technology name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedTechnology.type
      description: Recorded Future related technology type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedEmailAddress.count
      description: Recorded Future related email address count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedEmailAddress.id
      description: Recorded Future related email address ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedEmailAddress.name
      description: Recorded Future related email address name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedEmailAddress.type
      description: Recorded Future related email address type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttackVector.count
      description: Recorded Future related attack vector count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttackVector.id
      description: Recorded Future related attack vector ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttackVector.name
      description: Recorded Future related attack vector name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedAttackVector.type
      description: Recorded Future related attack vector type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalwareCategory.count
      description: Recorded Future related malware category count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalwareCategory.id
      description: Recorded Future related malware category ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalwareCategory.name
      description: Recorded Future related malware category name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedMalwareCategory.type
      description: Recorded Future related malware category type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedOperations.count
      description: Recorded Future related operations count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedOperations.id
      description: Recorded Future related operations ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedOperations.name
      description: Recorded Future related operations name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedOperations.type
      description: Recorded Future related operations type
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCompany.count
      description: Recorded Future related company count
      type: number
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCompany.id
      description: Recorded Future related company ID
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCompany.name
      description: Recorded Future related company name
      type: string
    - contextPath: RecordedFuture.Domain.relatedEntities.RelatedCompany.type
      description: Recorded Future related company type
      type: string
    - contextPath: RecordedFuture.CVE.criticality
      description: Risk Criticality
      type: number
    - contextPath: RecordedFuture.CVE.criticalityLabel
      description: Risk Criticality Label
      type: string
    - contextPath: RecordedFuture.CVE.riskString
      description: Risk String
      type: string
    - contextPath: RecordedFuture.CVE.riskSummary
      description: Risk Summary
      type: string
    - contextPath: RecordedFuture.CVE.rules
      description: Risk Rules
      type: string
    - contextPath: RecordedFuture.CVE.concatRules
      description: All risk rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.CVE.score
      description: Risk Score
      type: number
    - contextPath: RecordedFuture.CVE.firstSeen
      description: Evidence First Seen
      type: date
    - contextPath: RecordedFuture.CVE.lastSeen
      description: Evidence Last Seen
      type: date
    - contextPath: RecordedFuture.CVE.intelCard
      description: Recorded Future Intelligence Card URL
      type: string
    - contextPath: RecordedFuture.CVE.hashAlgorithm
      description: Hash Algorithm
      type: string
    - contextPath: RecordedFuture.CVE.type
      description: Entity Type
      type: string
    - contextPath: RecordedFuture.CVE.name
      description: Entity
      type: string
    - contextPath: RecordedFuture.CVE.id
      description: Recorded Future Entity ID
      type: string
    - contextPath: RecordedFuture.CVE.metrics.type
      description: Recorded Future Metrics Type
      type: string
    - contextPath: RecordedFuture.CVE.metrics.value
      description: Recorded Future Metrics Value
      type: number
    - contextPath: RecordedFuture.CVE.threatLists.description
      description: Recorded Future Threat List Description
      type: string
    - contextPath: RecordedFuture.CVE.threatLists.id
      description: Recorded Future Threat List ID
      type: string
    - contextPath: RecordedFuture.CVE.threatLists.name
      description: Recorded Future Threat List Name
      type: string
    - contextPath: RecordedFuture.CVE.threatLists.type
      description: Recorded Future Threat List Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttacker.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttacker.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttacker.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttacker.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTarget.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTarget.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTarget.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTarget.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedThreatActor.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedThreatActor.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedThreatActor.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedThreatActor.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalware.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalware.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalware.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalware.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCyberVulnerability.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCyberVulnerability.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCyberVulnerability.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCyberVulnerability.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedIpAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedIpAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedIpAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedIpAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedInternetDomainName.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedInternetDomainName.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedInternetDomainName.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedInternetDomainName.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedProduct.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedProduct.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedProduct.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedProduct.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCountries.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCountries.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCountries.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCountries.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedHash.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedHash.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedHash.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedHash.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTechnology.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTechnology.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTechnology.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedTechnology.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedEmailAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedEmailAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedEmailAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedEmailAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttackVector.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttackVector.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttackVector.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedAttackVector.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalwareCategory.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalwareCategory.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalwareCategory.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedMalwareCategory.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedOperations.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedOperations.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedOperations.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedOperations.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCompany.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCompany.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCompany.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.CVE.relatedEntities.RelatedCompany.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.CVE.cpe
      description: Recorded Future CPE information
      type: string
    - contextPath: RecordedFuture.CVE.relatedLinks
      description: Recorded Future CVE Related Links
      type: string
    - contextPath: RecordedFuture.File.criticality
      description: Risk Criticality
      type: number
    - contextPath: RecordedFuture.File.criticalityLabel
      description: Risk Criticality Label
      type: string
    - contextPath: RecordedFuture.File.riskString
      description: Risk String
      type: string
    - contextPath: RecordedFuture.File.riskSummary
      description: Risk Summary
      type: string
    - contextPath: RecordedFuture.File.rules
      description: Risk Rules
      type: string
    - contextPath: RecordedFuture.File.concatRules
      description: All risk rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.File.score
      description: Risk Score
      type: number
    - contextPath: RecordedFuture.File.firstSeen
      description: Evidence First Seen
      type: date
    - contextPath: RecordedFuture.File.lastSeen
      description: Evidence Last Seen
      type: date
    - contextPath: RecordedFuture.File.intelCard
      description: Recorded Future Intelligence Card URL
      type: string
    - contextPath: RecordedFuture.File.hashAlgorithm
      description: Hash Algorithm
      type: string
    - contextPath: RecordedFuture.File.type
      description: Entity Type
      type: string
    - contextPath: RecordedFuture.File.name
      description: Entity
      type: string
    - contextPath: RecordedFuture.File.id
      description: Recorded Future Entity ID
      type: string
    - contextPath: RecordedFuture.File.metrics.type
      description: Recorded Future Metrics Type
      type: string
    - contextPath: RecordedFuture.File.metrics.value
      description: Recorded Future Metrics Value
      type: number
    - contextPath: RecordedFuture.File.threatLists.description
      description: Recorded Future Threat List Description
      type: string
    - contextPath: RecordedFuture.File.threatLists.id
      description: Recorded Future Threat List ID
      type: string
    - contextPath: RecordedFuture.File.threatLists.name
      description: Recorded Future Threat List Name
      type: string
    - contextPath: RecordedFuture.File.threatLists.type
      description: Recorded Future Threat List Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttacker.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttacker.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttacker.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttacker.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTarget.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTarget.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTarget.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTarget.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedThreatActor.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedThreatActor.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedThreatActor.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedThreatActor.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalware.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalware.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalware.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalware.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCyberVulnerability.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCyberVulnerability.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCyberVulnerability.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCyberVulnerability.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedIpAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedIpAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedIpAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedIpAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedInternetDomainName.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedInternetDomainName.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedInternetDomainName.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedInternetDomainName.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedProduct.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedProduct.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedProduct.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedProduct.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCountries.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCountries.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCountries.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCountries.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedHash.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedHash.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedHash.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedHash.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTechnology.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTechnology.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTechnology.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedTechnology.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedEmailAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedEmailAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedEmailAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedEmailAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttackVector.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttackVector.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttackVector.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedAttackVector.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalwareCategory.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalwareCategory.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalwareCategory.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedMalwareCategory.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedOperations.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedOperations.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedOperations.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedOperations.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCompany.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCompany.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCompany.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.File.relatedEntities.RelatedCompany.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.criticality
      description: Risk Criticality
      type: number
    - contextPath: RecordedFuture.URL.criticalityLabel
      description: Risk Criticality Label
      type: string
    - contextPath: RecordedFuture.URL.riskString
      description: Risk String
      type: string
    - contextPath: RecordedFuture.URL.riskSummary
      description: Risk Summary
      type: string
    - contextPath: RecordedFuture.URL.rules
      description: Risk Rules
      type: string
    - contextPath: RecordedFuture.URL.concatRules
      description: All risk rules concatenated by comma
      type: string
    - contextPath: RecordedFuture.URL.score
      description: Risk Score
      type: number
    - contextPath: RecordedFuture.URL.firstSeen
      description: Evidence First Seen
      type: date
    - contextPath: RecordedFuture.URL.lastSeen
      description: Evidence Last Seen
      type: date
    - contextPath: RecordedFuture.URL.intelCard
      description: Recorded Future Intelligence Card URL
      type: string
    - contextPath: RecordedFuture.URL.type
      description: Entity Type
      type: string
    - contextPath: RecordedFuture.URL.name
      description: Entity
      type: string
    - contextPath: RecordedFuture.URL.id
      description: Recorded Future Entity ID
      type: string
    - contextPath: RecordedFuture.URL.metrics.type
      description: Recorded Future Metrics Type
      type: string
    - contextPath: RecordedFuture.URL.metrics.value
      description: Recorded Future Metrics Value
      type: number
    - contextPath: RecordedFuture.URL.threatLists.description
      description: Recorded Future Threat List Description
      type: string
    - contextPath: RecordedFuture.URL.threatLists.id
      description: Recorded Future Threat List ID
      type: string
    - contextPath: RecordedFuture.URL.threatLists.name
      description: Recorded Future Threat List Name
      type: string
    - contextPath: RecordedFuture.URL.threatLists.type
      description: Recorded Future Threat List Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttacker.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttacker.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttacker.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttacker.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTarget.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTarget.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTarget.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTarget.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedThreatActor.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedThreatActor.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedThreatActor.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedThreatActor.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalware.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalware.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalware.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalware.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCyberVulnerability.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCyberVulnerability.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCyberVulnerability.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCyberVulnerability.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedIpAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedIpAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedIpAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedIpAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedInternetDomainName.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedInternetDomainName.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedInternetDomainName.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedInternetDomainName.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedProduct.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedProduct.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedProduct.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedProduct.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCountries.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCountries.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCountries.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCountries.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedHash.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedHash.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedHash.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedHash.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTechnology.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTechnology.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTechnology.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedTechnology.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedEmailAddress.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedEmailAddress.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedEmailAddress.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedEmailAddress.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttackVector.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttackVector.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttackVector.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedAttackVector.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalwareCategory.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalwareCategory.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalwareCategory.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedMalwareCategory.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedOperations.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedOperations.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedOperations.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedOperations.type
      description: Recorded Future Related Type
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCompany.count
      description: Recorded Future Related Count
      type: number
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCompany.id
      description: Recorded Future Related ID
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCompany.name
      description: Recorded Future Related Name
      type: string
    - contextPath: RecordedFuture.URL.relatedEntities.RelatedCompany.type
      description: Recorded Future Related Type
      type: string
  - arguments:
    - auto: PREDEFINED
      description: The type of entity for which to fetch context. Should be provided
        with its value in entityValue argument. Can be "domain", "ip", "file", "url",
        or "cve".
      name: entity_type
      predefined:
      - domain
      - ip
      - file
      - url
      - cve
      required: true
    - description: 'The value of the entity for which to fetch context. Should be
        provided with its type in entity_type argument. Supported hash types: MD5,
        SHA1, SHA256, SHA512, CRC32, and CTPH. Vulnerability supports CVEs.'
      name: entity
      required: true
    description: Get Insikt Group Research Links for an IP, Domain, CVE, URL or File.
    name: recordedfuture-links
    outputs:
    - contextPath: RecordedFuture.Links.category
      description: Recorded Future links category
      type: String
    - contextPath: RecordedFuture.Links.type
      description: Recorded Future Links Type
      type: String
    - contextPath: RecordedFuture.Links.lists.entity_type
      description: Recorded Future Links type
      type: String
    - contextPath: RecordedFuture.Links.lists.entities.type
      description: RRecorded Future Link entity type
      type: String
    - contextPath: RecordedFuture.Links.lists.entities.name
      description: Recorded Future Link entity name
      type: String
    - contextPath: RecordedFuture.Links.lists.entities.score
      description: Recorded Future Link Entity Risk Score
      type: Number
  - arguments:
    - description: Alert id
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: The status we want to set for the alert in Recorded Future
      name: status
      predefined:
      - unassigned
      - assigned
      - pending
      - dismiss
      - no-action
      - actionable
      - tuning
      required: true
    description: Set alert into predefined status
    name: recordedfuture-alert-set-status
    outputs:
    - contextPath: RecordedFuture.Alerts.id
      description: Recorded Future alert id
      type: String
    - contextPath: RecordedFuture.Alerts.status
      description: Recorded Future alert status
      type: String
    - contextPath: RecordedFuture.Alerts.note.text
      description: Recorded Future alert note text
      type: String
    - contextPath: RecordedFuture.Alerts.note.author
      description: Recorded Future alert note author
      type: String
    - contextPath: RecordedFuture.Alerts.note.date
      description: Recorded Future alert note date
      type: date
    - contextPath: RecordedFuture.Alerts.reviewDate
      description: Recorded Future alert get date
      type: date
  - arguments:
    - description: Alert id
      name: alert_id
      required: true
    - description: The note of the id we want to set
      name: note
      required: true
    description: Set a note for the alert in Recorded Future
    name: recordedfuture-alert-set-note
    outputs:
    - contextPath: RecordedFuture.Alerts.id
      description: Recorded Future alert id
      type: String
    - contextPath: RecordedFuture.Alerts.status
      description: Recorded Future alert status
      type: String
    - contextPath: RecordedFuture.Alerts.note.text
      description: Recorded Future alert note text
      type: String
    - contextPath: RecordedFuture.Alerts.note.author
      description: Recorded Future alert note author
      type: String
    - contextPath: RecordedFuture.Alerts.note.date
      description: Recorded Future alert note date
      type: date
    - contextPath: RecordedFuture.Alerts.reviewDate
      description: Recorded Future alert get date
      type: date
  dockerimage: demisto/python3:3.9.8.24399
  isfetch: true
  runonce: false
  script: |
    register_module_line('Recorded Future v2', 'start', __line__())
    """Recorded Future Integration for Demisto."""
    from typing import Dict, Any, List, Tuple
    from urllib import parse
    import requests
    import json
    import re

    # flake8: noqa: F402,F405 lgtm



    STATUS_TO_RETRY = [500, 501, 502, 503, 504]

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()  # pylint:disable=no-member

    __version__ = '2.3'


    def rename_keys(old_to_new: Dict[str, str], original: Dict[str, Any]):
        for old, new in old_to_new.items():
            original[new] = original[old]
            del original[old]
        return original


    class Client(BaseClient):
        def whoami(self) -> Dict[str, Any]:
            """Entity lookup."""
            return self._http_request(
                method="get",
                url_suffix="info/whoami",
                timeout=60,
            )

        def entity_lookup(
                self, entities: List[str], entity_type: str) -> Dict[str, Any]:
            """Entity lookup."""
            if entity_type == "file":
                entity_type = "hash"
            elif entity_type == "cve":
                entity_type = "vulnerability"
            return self._http_request(
                method="post",
                url_suffix="soar/enrichment",
                json_data={entity_type: entities},
                timeout=120,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )

        def entity_enrich(
            self, entity: str, entity_type: str,
                related: bool, risky: bool,
                profile: str = 'All'
        ) -> Dict[str, Any]:
            """Entity enrich."""

            profiles = {
                "Vulnerability Analyst": [
                    "RelatedMalwareCategory",
                    "RelatedMalware",
                    "RelatedThreatActor"
                ],
                "TI Analyst": [
                    "RelatedIpAddress",
                    "RelatedMalwareCategory",
                    "RelatedMalware",
                    "RelatedThreatActor"
                ],
                "SecOp Analyst": [
                    "RelatedMalwareCategory",
                    "RelatedMalware",
                ],
                "Threat Hunter": [
                    "RelatedInternetDomainName",
                    "RelatedHash",
                    "RelatedMalware",
                    "RelatedAttackVector"
                ]
            }

            intel_map = {
                "ip": [
                    "entity",
                    "risk",
                    "timestamps",
                    "threatLists",
                    "intelCard",
                    "metrics",
                    "location",
                    "relatedEntities",
                    "riskyCIDRIPs",
                    "links",
                ],
                "domain": [
                    "entity",
                    "risk",
                    "timestamps",
                    "threatLists",
                    "intelCard",
                    "metrics",
                    "relatedEntities",
                    "links",
                ],
                "hash": [
                    "entity",
                    "risk",
                    "timestamps",
                    "threatLists",
                    "intelCard",
                    "metrics",
                    "hashAlgorithm",
                    "relatedEntities",
                    "links",
                ],
                "vulnerability": [
                    "entity",
                    "risk",
                    "timestamps",
                    "threatLists",
                    "intelCard",
                    "metrics",
                    "cvss",
                    "nvdDescription",
                    "relatedEntities",
                    "cpe",
                    "relatedLinks",
                    "links",
                ],
                "url": [
                    "entity",
                    "risk",
                    "timestamps",
                    "metrics",
                    "relatedEntities",
                    "links",
                ],
            }
            if entity_type == "url" or entity_type == "ip":
                entity = parse.quote_plus(entity)
            elif entity_type == "file":
                entity_type = "hash"
            elif entity_type == "cve":
                entity_type = "vulnerability"
            cmd_url = f"{entity_type}/{entity.strip()}"
            fields = intel_map[entity_type]
            if entity_type == "ip" and not risky:
                fields.remove("riskyCIDRIPs")
            if not related and profile != 'All':
                fields.remove("relatedEntities")
            req_fields = ",".join(fields)
            params = {"fields": req_fields}
            resp = self._http_request(
                method="get", url_suffix=cmd_url, params=params, timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )
            if profile != 'All' and related:
                related_entities = resp['data']['relatedEntities']
                related_entities = [
                    entry for entry in related_entities
                    if entry['type'] in profiles[profile]
                ]
                resp['data']['relatedEntities'] = related_entities
            return resp

        def get_single_alert(self, _id):
            """Get a single alert"""
            return self._http_request(
                method="get",
                url_suffix=f"alert/{_id}",
                timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )

        def get_alert_rules(self, rule_name: str, limit: int = None) -> Dict[str, Any]:
            """Get Alert Rules."""
            params: Dict[str, Any] = {}
            if rule_name:
                params["freetext"] = rule_name.strip()
            if limit:
                params["limit"] = limit
            return self._http_request(
                method="get",
                url_suffix="alert/rule",
                params=params,
                timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )

        def get_alerts(self, params: Dict[str, Any]) -> Dict[str, Any]:
            """Get Alerts."""
            return self._http_request(
                method="get",
                url_suffix="alert/search",
                params=params,
                timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )

        def update_alerts(self, data: Union[List, Dict]):
            """Update Alerts"""
            return self._http_request(
                method="post",
                url_suffix="alert/update",
                json_data=data,
                timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY,
            )

        def get_triage(
            self, entities: Dict[str, List], context: str
        ) -> Dict[str, Any]:
            """SOAR triage lookup."""
            return self._http_request(
                method="post",
                url_suffix=f"soar/triage/contexts/{context}" "?format=phantom",
                json_data=entities,
                timeout=30,
                retries=3,
                status_list_to_retry=STATUS_TO_RETRY
            )


    def translate_score(score: int, threshold: int) -> int:
        """Translate Recorded Future score to DBot score."""
        RISK_SCORE_THRESHOLD = 25
        # see https://support.recordedfuture.com/hc/en-us/articles/115000894468-Vulnerability-Risk-Rules # noqa
        if score >= threshold:
            return Common.DBotScore.BAD
        elif score >= RISK_SCORE_THRESHOLD:
            return Common.DBotScore.SUSPICIOUS
        else:
            return Common.DBotScore.NONE


    def parse_cpe(cpes: list) -> list:
        dicts = []
        parts = {
            'o': 'Operating System',
            'a': 'Application',
            'h': 'Hardware',
            '*': 'Any',
            '-': 'NA'
        }
        cpe_regex = re.compile(
            r'cpe:2\.3:(?P<Part>[aoh*-]):(?P<Vendor>[a-zA-Z_-]+):'
            r'(?P<Product>[A-Za-z0-9_-]+):(?P<Version>[0-9.]+):(?P<Update>[a-zA-Z0-9*]+):'
            r'(?P<Edition>[a-zA-Z0-9*]+):(?P<Language>[a-zA-Z0-9*]+):'
            r'(?P<swedition>[a-zA-Z0-9*]+):(?P<targetsw>[a-zA-Z0-9*]+):'
            r'(?P<targethw>[a-zA-Z0-9*]+):(?P<Other>[a-zA-Z0-9*]+)'
        )
        for cpe in cpes:
            try:
                match = cpe_regex.match(cpe)
                if match:
                    tmp_dict = match.groupdict()
                    tmp_dict['Part'] = parts[tmp_dict.get('Part', '-')]
                    tmp_dict['Software Edition'] = tmp_dict.pop('swedition')
                    tmp_dict['Target Software'] = tmp_dict.pop('targetsw')
                    tmp_dict['Target Hardware'] = tmp_dict.pop('targethw')
                    dicts.append(tmp_dict)
            except:
                continue
        return dicts


    def determine_hash(hash_value: str) -> str:
        """Determine hash type by length."""
        hash_length = len(hash_value)
        if hash_length == 128:
            return "SHA512"
        elif hash_length == 64:
            return "SHA256"
        elif hash_length == 40:
            return "SHA1"
        elif hash_length == 32:
            return "MD5"
        elif hash_length == 8:
            return "CRC32"
        else:
            return "CTPH"


    def level_to_criticality(level: int) -> str:
        """Translate level integer to Criticality string."""
        if level >= 4:
            return "Very Malicious"
        elif level >= 3:
            return "Malicious"
        elif level >= 2:
            return "Suspicious"
        elif level >= 1:
            return "Informational"
        return "Unknown"


    def rf_type_to_xsoar_type(entity_type: str) -> str:
        if entity_type == "IpAddress":
            return "ip"
        elif entity_type == "Hash":
            return "file"
        elif entity_type == "URL":
            return "url"
        elif entity_type == "CyberVulnerability":
            return "cve"
        elif entity_type == "InternetDomainName":
            return "domain"
        raise DemistoException(
            f"Unknown Recorded Future " f"entity type: {entity_type}"
        )


    def prettify_time(time_string: str) -> str:
        """Fix timestamps to a better format."""
        if time_string:
            parsed = datetime.strptime(time_string, "%Y-%m-%dT%H:%M:%S.%fZ")
            return datetime.strftime(parsed, "%Y-%m-%d %H:%M:%S")
        else:
            return "N/A"


    def create_indicator(
        entity: str,
        entity_type: str,
        score: int,
        description: str,
        location: Dict[str, Any] = {},
    ) -> Common.Indicator:
        """Create an Indicator object."""
        demisto_params = demisto.params()
        thresholds = {
            "file": int(demisto_params.get("file_threshold", 65)),
            "ip": int(demisto_params.get("ip_threshold", 65)),
            "domain": int(demisto_params.get("domain_threshold", 65)),
            "url": int(demisto_params.get("url_threshold", 65)),
            "cve": int(demisto_params.get("cve_threshold", 65)),
        }
        dbot_score = translate_score(score, thresholds[entity_type])
        dbot_description = (
            f"Score above {thresholds[entity_type]}"
            if dbot_score == Common.DBotScore.BAD
            else None
        )
        dbot_vendor = "Recorded Future v2"
        if entity_type == "ip":
            return Common.IP(
                entity,
                Common.DBotScore(
                    entity,
                    DBotScoreType.IP,

                    dbot_vendor,
                    dbot_score,
                    dbot_description,
                ),
                asn=location.get("asn", None),
                geo_country=location.get("location", {}).get("country", None),
            )
        elif entity_type == "domain":
            return Common.Domain(
                entity,
                Common.DBotScore(
                    entity,
                    DBotScoreType.DOMAIN,
                    dbot_vendor,
                    dbot_score,
                    dbot_description,
                ),
            )
        elif entity_type == "file":
            dbot_obj = Common.DBotScore(
                entity,
                DBotScoreType.FILE,
                dbot_vendor,
                dbot_score,
                dbot_description,
            )
            hash_type = determine_hash(entity)
            if hash_type == "MD5":
                return Common.File(dbot_obj, md5=entity)
            elif hash_type == "SHA1":
                return Common.File(dbot_obj, sha1=entity)
            elif hash_type == "SHA256":
                return Common.File(dbot_obj, sha256=entity)
            elif hash_type == "SHA512":
                return Common.File(dbot_obj, sha512=entity)
            else:
                return Common.File(dbot_obj)
        elif entity_type == "cve":
            return Common.CVE(entity, "", "", "", description)
        elif entity_type == "url":
            return Common.URL(
                entity,
                Common.DBotScore(
                    entity,
                    DBotScoreType.URL,
                    dbot_vendor,
                    dbot_score,
                    dbot_description,
                ),
            )
        else:
            raise Exception(
                "Could not create indicator for this "
                f"type of entity: {entity_type}"
            )


    def get_output_prefix(entity_type: str) -> str:
        if entity_type in ["cve", "vulnerability"]:
            return "RecordedFuture.CVE"
        elif entity_type == "ip":
            return "RecordedFuture.IP"
        elif entity_type == "domain":
            return "RecordedFuture.Domain"
        elif entity_type == "url":
            return "RecordedFuture.URL"
        elif entity_type in ["file", "vulnerability"]:
            return "RecordedFuture.File"
        elif entity_type == "links":
            return "RecordedFuture.Links"
        elif entity_type == "alerts":
            return "RecordedFuture.Alerts"
        else:
            raise Exception(f"Unknown entity type: {entity_type}")


    #####################
    #    Actions        #
    #####################


    class Actions():

        def __init__(self, rf_client: Client):
            self.client = rf_client

        def lookup_command(
            self, entities: List[str], entity_type: str
        ) -> List[CommandResults]:
            """Entity lookup command."""
            entity_data = self.client.entity_lookup(entities, entity_type)
            command_results = self.__build_rep_context(entity_data, entity_type)
            return command_results

        def __build_rep_markdown(
            self, ent: Dict[str, Any], entity_type: str
        ) -> str:
            """Build Reputation Markdown."""
            markdown = []
            entity_title = (
                entity_type.upper()
                if entity_type in ["ip", "url", "cve"]
                else entity_type.title()
            )
            try:
                evidence = ent["risk"]["rule"]["evidence"]
            except KeyError:
                evidence = {}
            markdown.append(
                "\n".join(
                    [
                        f"### Recorded Future {entity_title} reputation "
                        f'for {ent["entity"]["name"]}',
                        f'Risk score: {int(ent["risk"]["score"])}',
                        f'Risk Summary: {ent["risk"]["rule"]["count"]} out of '
                        f'{ent["risk"]["rule"]["maxCount"]} '
                        f"Risk Rules currently observed",
                        f'Criticality: {level_to_criticality(ent["risk"]["level"])}'
                        f"\n",
                    ]
                )
            )
            if ent["entity"].get("description", None):
                markdown.append(
                    f"NVD Vulnerability Description: "
                    f'{ent["entity"]["description"]}\n'
                )
            if ent["entity"].get("id", None):
                markdown.append(
                    "[Intelligence Card]"
                    "(https://app.recordedfuture.com"
                    f'/live/sc/entity/{ent["entity"]["id"]})\n'
                )
            if evidence:
                evid_table = [
                    {
                        "Rule": detail["rule"],
                        "Criticality": level_to_criticality(detail["level"]),
                        "Evidence": detail["description"],
                        "Timestamp": prettify_time(detail["timestamp"]),
                        "Level": detail["level"],
                    }
                    for x, detail in evidence.items()
                ]
                evid_table.sort(key=lambda x: x.get("Level"), reverse=True)  # type: ignore
                markdown.append(
                    tableToMarkdown(
                        "Risk Rules Triggered",
                        evid_table,
                        ["Criticality", "Rule", "Evidence", "Timestamp"],
                        removeNull=True,
                    )
                )
            return "\n".join(markdown)

        def __build_rep_context(
            self, entity_data: Dict[str, Any], entity_type: str
        ) -> List[CommandResults]:
            """Build Reputation Context."""
            if entity_type == "hash":
                entity_type = "file"
            elif entity_type == "vulnerability":
                entity_type = "cve"

            command_results: List[CommandResults] = []
            if entity_data and ("error" not in entity_data):
                for ent in entity_data["data"]["results"]:
                    try:
                        evidence = ent["risk"]["rule"]["evidence"]
                    except KeyError:
                        evidence = {}
                    concat_rules = ','.join([e["rule"] for e in evidence.values()])
                    context = (
                        {
                            "riskScore": ent["risk"]["score"],
                            "Evidence": [
                                {
                                    "rule": dic["rule"],
                                    "mitigation": dic["mitigation"],
                                    "description": dic["description"],
                                    "timestamp": prettify_time(dic["timestamp"]),
                                    "level": dic["level"],
                                    "ruleid": key,
                                }
                                if dic.get("mitigation", None)
                                else {
                                    "rule": dic["rule"],
                                    "description": dic["description"],
                                    "timestamp": prettify_time(dic["timestamp"]),
                                    "level": dic["level"],
                                    "ruleid": key,
                                }
                                for key, dic in evidence.items()
                            ],
                            "riskLevel": ent["risk"]["level"],
                            "id": ent["entity"]["id"],
                            "ruleCount": ent["risk"]["rule"]["count"],
                            "rules": concat_rules,
                            "maxRules": ent["risk"]["rule"]["maxCount"],
                            "description": ent["entity"].get("description", ""),
                            "name": ent["entity"]["name"],
                        }
                    )
                    indicator = create_indicator(
                        ent["entity"]["name"],
                        entity_type,
                        ent["risk"]["score"],
                        ent["entity"].get("description", ""),
                    )
                    command_results.append(CommandResults(
                        outputs_prefix=get_output_prefix(entity_type),
                        outputs=context,
                        raw_response=entity_data,
                        readable_output=self.__build_rep_markdown(ent, entity_type),
                        outputs_key_field='name',
                        indicator=indicator
                    ))
                return command_results
            else:
                return [CommandResults(
                    readable_output="No records found"
                )]

        def triage_command(
            self, entities: Dict[str, List[str]], context: str
        ) -> List[CommandResults]:
            """Do Auto Triage."""
            zero_filter = entities.pop('filter', False)

            def include_score(score):
                if zero_filter and score > 0:
                    return True
                elif not zero_filter:
                    return True
                else:
                    return False

            context_data = self.client.get_triage(entities, context)
            entities = [e for e in context_data["entities"] if include_score(e["score"])]  # type: ignore
            context_data["entities"] = entities
            output_context, command_results = self.__build_triage_context(context_data)
            command_results.append(
                CommandResults(
                    outputs_prefix="RecordedFuture",
                    outputs=output_context,
                    raw_response=context_data,
                    readable_output=self.__build_triage_markdown(context_data, context),
                    outputs_key_field="verdict",
                )
            )
            return command_results

        def __build_triage_markdown(
            self, context_data: Dict[str, Any], context: str
        ) -> str:
            """Build Auto Triage output."""
            verdict = (
                "Suspected Malicious" if context_data["verdict"] else "Non-malicious"
            )
            md = "\n".join(
                [
                    "### Recorded Future Threat Assessment with regards "
                    f"to {context}",
                    f"Verdict: {verdict}",
                    f'Max/Min Score: {context_data["scores"]["max"]}/'
                    f'{context_data["scores"]["min"]}\n',
                ]
            )
            tables = [md, "### Entities"]
            for entity in context_data.get("entities", []):
                header = "\n".join(
                    [
                        f'Entity: {entity["name"]}',
                        f'Score: {entity["score"]}',
                        f'Rule count: {entity["rule"]["count"]} out '
                        f'of {entity["rule"]["maxCount"]}',
                    ]
                )
                table = [
                    {
                        "Rule Name": x["rule"],
                        "Rule Criticality": level_to_criticality(x["level"]),
                        "Rule Timestamp": prettify_time(x["timestamp"]),
                        "Rule Description": x["description"],
                        "Level": x["level"],
                    }
                    for x in entity["rule"]["evidence"]
                ]
                table.sort(key=lambda x: x.get("Level"), reverse=True)  # type: ignore
                tables.append(
                    "\n".join(
                        [
                            header,
                            tableToMarkdown(
                                "Evidence",
                                table,
                                [
                                    "Rule Name",
                                    "Rule Criticality",
                                    "Rule Timestamp",
                                    "Rule Description",
                                ],
                                removeNull=True,
                            ),
                        ]
                    )
                )
            return "\n".join(tables)

        def __build_triage_context(
            self, context_data: Dict[str, Any]
        ) -> Tuple[Dict[str, Any], List]:
            """Build Auto Triage output."""
            context = {
                "context": context_data.get("context", "Unknown"),
                "verdict": context_data.get("verdict", "Unknown"),
                "riskScore": context_data["scores"]["max"],
                "Entities": [
                    {
                        "id": entity["id"],
                        "name": entity["name"],
                        "type": entity["type"],
                        "score": entity["score"],
                        "Evidence": entity["rule"]["evidence"],
                        "context": context_data.get("context", '') if entity["rule"]["evidence"] else ""
                    }
                    for entity in context_data["entities"]
                ],
            }
            command_results: List[CommandResults] = []
            for entity in context_data['entities']:
                indicator = create_indicator(
                    entity['name'],
                    rf_type_to_xsoar_type(entity['type']),
                    entity['score'],
                    ''
                )
                readable_output = tableToMarkdown(
                    'New Indicator was created', indicator.to_context()
                )
                command_result = CommandResults(
                    outputs=context,
                    readable_output=readable_output,
                    indicator=indicator
                )
                command_results.append(command_result)
            return context, command_results

        def enrich_command(
            self, entity: str, entity_type: str, related: bool, risky: bool, profile: str = "All"
        ) -> List[CommandResults]:
            """Enrich command."""
            try:
                entity_data = self.client.entity_enrich(entity, entity_type, related, risky, profile)
                if entity_data.get("data", {}).get("relatedEntities"):
                    entity_data["data"]["relatedEntities"] = self.__handle_related_entities(
                        entity_data["data"].pop("relatedEntities")
                    )
                markdown = self.__build_intel_markdown(entity_data, entity_type)
                return self.__build_intel_context(entity, entity_data, entity_type, markdown)
            except DemistoException as err:
                if "404" in str(err):
                    return [CommandResults(
                        outputs_prefix="",
                        outputs={},
                        raw_response={},
                        readable_output="No results found.",
                        outputs_key_field="",
                    )]
                else:
                    raise err

        def __build_intel_markdown(self, entity_data: Dict[str, Any], entity_type: str) -> str:
            """Build Intelligence markdown."""
            if entity_data and ("error" not in entity_data):
                if entity_type == "hash":
                    entity_type = "file"
                elif entity_type == "vulnerability":
                    entity_type = "cve"
                entity_title = (
                    entity_type.upper()
                    if entity_type in ["ip", "url", "cve"]
                    else entity_type.title()
                )
                data = entity_data["data"]
                risk = data["risk"]
                for hits in data["metrics"]:
                    if hits["type"] == "totalHits":
                        total_hits = hits["value"]
                        break
                else:
                    total_hits = 0
                markdown = [
                    f"### Recorded Future {entity_title} Intelligence for "
                    f'{data["entity"]["name"]}',
                    f'Risk Score: {risk.get("score", "N/A")}',
                    f'Summary: {risk.get("riskSummary", "N/A")}',
                    f'Criticality label: {risk["criticalityLabel"] if risk.get("criticalityLabel") else "N/A"}',
                    f"Total references to this entity: {total_hits}",
                ]
                if entity_type == "ip":
                    loc = data.get("location", {})
                    locloc = loc.get("location", {})
                    markdown.extend(
                        [
                            "ASN and Geolocation",
                            f'AS Number: {loc["asn"] if loc.get("asn") else "N/A"}',
                            f'AS Name: {loc["organization"] if loc.get("organization") else "N/A"}',
                            f'CIDR: {loc["cidr"].get("name", "N/A") if loc.get("cidr") else "N/A"}',
                            "Geolocation (city): " f'{locloc["city"] if locloc.get("city") else "N/A"}',
                            "Geolocation (country): "
                            f'{locloc["country"] if locloc.get("country") else "N/A"}',
                        ]
                    )
                tstamps = data.get("timestamps", {})
                markdown.extend(
                    [
                        "First reference collected on: "
                        f'{prettify_time(tstamps.get("firstSeen"))}',
                        "Latest reference collected on: "
                        f'{prettify_time(tstamps.get("lastSeen"))}',
                    ]
                )
                if data.get("intelCard", None):
                    markdown.append(f'[Intelligence Card]({data["intelCard"]})\n')
                else:
                    markdown.append(
                        "[Intelligence Card]"
                        "(https://app.recordedfuture.com/"
                        f'live/sc/entity/{data["entity"]["id"]})\n'
                    )
                if entity_type == "cve":
                    markdown.append(
                        "NVD Summary: " f'{data.get("nvdDescription", "N/A")}'
                    )
                    if data.get("cvssv3", None):
                        cdata = data["cvssv3"]
                        cvss = [
                            "CVSSv3 Information",
                            "Attack Vector: "
                            f'{cdata.get("attackVector", "N/A").title()}',
                            "Attack Complexity: "
                            f'{cdata.get("attackComplexity", "N/A").title()}',
                            f'CVSSv3 Score: {cdata.get("baseScore", "N/A")}',
                            f'Impact Score: {cdata.get("impactScore", "N/A")},'
                            "Exploitability Score: "
                            f'{cdata.get("exploitabilityScore", "N/A")}',
                            "Availability: "
                            f'{cdata.get("availabilityImpact", "N/A").title()}',
                            "Availability Impact: "
                            f'{cdata.get("availabilityImpact", "N/A").title()}',
                            "User Interaction: "
                            f'{cdata.get("userInteraction", "N/A").title()}',
                            "Privileges Required: "
                            f'{cdata.get("privilegesRequired", "N/A").title()}',
                            "Integrity Impact: "
                            f'{cdata.get("integrityImpact", "N/A").title()}',
                            "Confidentiality Impact: "
                            f'{cdata.get("confidentialityImpact", "N/A").title()}',
                            f'Published: {prettify_time(cdata.get("created"))}',
                            "Last Modified: "
                            f'{prettify_time(cdata.get("modified"))}',
                        ]
                    else:
                        cdata = data.get("cvss", {})
                        cvss = [
                            "CVSS Information",
                            "Access Vector: "
                            f'{cdata.get("accessVector", "N/A").title()}',
                            "Availability: "
                            f'{cdata.get("availability", "N/A").title()}',
                            f'CVSS Score: {cdata.get("score", "N/A")}',
                            "Access Complexity: "
                            f'{cdata.get("accessComplexity", "N/A").title()}',
                            "Authentication: "
                            f'{cdata.get("authentication", "N/A").title()}',
                            "Confidentiality: "
                            f'{cdata.get("confidentiality", "N/A").title()}',
                            "Integrity Impact: "
                            f'{cdata.get("integrity", "N/A").title()}',
                            f'Published: {prettify_time(cdata.get("published"))}',
                            "Last Modified: "
                            f'{prettify_time(cdata.get("lastModified"))}',
                        ]
                    markdown.extend(cvss)
                    if data.get("cpe", None):
                        markdown.append(
                            tableToMarkdown(
                                "CPE Information",
                                parse_cpe(data.get("cpe")),
                                ['Part', 'Vendor', 'Product', 'Version', 'Update', 'Edition',
                                 'Language', 'Software Edition', 'Target Software',
                                 'Target Hardware', 'Other']
                            )
                        )
                    if data.get('relatedLinks', None):
                        markdown.append(tableToMarkdown(
                            "Related Links",
                            [{'Related Links': x} for x in data.get('relatedLinks')]
                        ))
                evidence_table = [
                    {
                        "Rule Criticality": detail.get("criticalityLabel"),
                        "Evidence Summary": detail.get("evidenceString"),
                        "Rule Triggered": detail.get("rule"),
                        "Rule Triggered Time": detail.get("timestamp"),
                        "Criticality": detail.get("criticality"),
                        "Mitigation": detail.get("mitigationString"),
                    }
                    for detail in risk["evidenceDetails"]
                ]
                evidence_table.sort(key=lambda x: x.get("Criticality"), reverse=True)  # type: ignore
                markdown.append(
                    tableToMarkdown(
                        "Triggered Risk Rules",
                        evidence_table,
                        [
                            "Rule Criticality",
                            "Rule Triggered",
                            "Evidence Summary",
                            "Mitigation",
                            "Rule Triggered Time",
                        ],
                        removeNull=True,
                    )
                )

                threatlist_table = [
                    {"Threat List Name": tl["name"], "Description": tl["description"]}
                    for tl in data.get("threatLists", [])
                ]
                markdown.append(
                    tableToMarkdown(
                        "Threat Lists",
                        threatlist_table,
                        ["Threat List Name", "Description"],
                    )
                )
                if data.get("relatedEntities"):
                    related_entities = {}
                    for related_entity in data["relatedEntities"]:
                        related_entities.update(related_entity)
                    table_values = {
                        key: [value['name'] for value in values]
                        for key, values in related_entities.items()
                    }
                    markdown.append(
                        tableToMarkdown(
                            "Related Entities",
                            table_values,
                            related_entities.keys()
                        )
                    )

                return "\n".join(markdown)
            else:
                return "No records found"

        def __build_intel_context(
            self, entity: str, entity_data: Dict[str, Any], entity_type: str, markdown: str
        ) -> List[CommandResults]:
            """Build Intelligence context."""
            if entity_type == "hash":
                entity_type = "file"
            elif entity_type == "vulnerability":
                entity_type = "cve"
            command_results: List[CommandResults] = []
            if entity_data and ("error" not in entity_data):
                data = entity_data.get("data")  # type: ignore
                if data:
                    data.update(data.pop("entity"))
                    data.update(data.pop("risk"))
                    data.update(data.pop("timestamps"))
                    evidence_details = data['evidenceDetails']
                    rules = ','.join([e['rule'] for e in evidence_details])
                    data['concatRules'] = rules

                command_results.append(
                    CommandResults(
                        outputs_prefix=get_output_prefix(entity_type),
                        outputs=data,
                        raw_response=entity_data,
                        readable_output=markdown,
                        outputs_key_field='name'
                    )
                )

                indicator = create_indicator(
                    entity,
                    entity_type,
                    data['score'],
                    data.get('description', ''),
                    location=data.get('location')
                )
                command_results.append(
                    CommandResults(
                        readable_output=tableToMarkdown(
                            'New indicator was created',
                            indicator.to_context()
                        ),
                        indicator=indicator
                    )
                )

                for cidr in data.get('riskyCIDRIPs', []):
                    indicator = create_indicator(
                        cidr['ip']['name'],
                        'ip',
                        cidr['score'],
                        f'IP in the same CIDR as {entity}',
                    )
                    command_results.append(
                        CommandResults(
                            readable_output=tableToMarkdown(
                                "New indicator was created",
                                indicator.to_context()
                            ),
                            indicator=indicator
                        )
                    )
            else:
                indicator = create_indicator(entity, entity_type, 0, '')
                command_results.append(
                    CommandResults(
                        readable_output=tableToMarkdown(
                            'New indicator was created',
                            indicator.to_context()
                        ),
                        indicator=indicator
                    )
                )
            return command_results

        def __handle_related_entities(self, data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
            return_data = []
            for related in data:
                return_data.append(
                    {
                        related["type"]: [
                            {
                                "count": x.get("count", 0),
                                "id": x.get("entity", {}).get("id", ""),
                                "name": x.get("entity", {}).get("name", ""),
                                "type": x.get("entity", {}).get("type", ""),
                            }
                            for x in related["entities"]
                        ]
                    }
                )
            return return_data

        def get_alert_rules_command(
            self, rule_name: str, limit: int
        ) -> Dict[str, Any]:
            """Get Alert Rules Command."""
            response = self.client.get_alert_rules(rule_name, limit)

            mapped_rules = [
                {"name": r.get("title", "N/A"), "id": r.get("id", "")}
                for r in response.get("data", {}).get("results", [])
            ]
            if not mapped_rules:
                return {
                    "Type": entryTypes["note"],
                    "Contents": {},
                    "ContentsFormat": formats["json"],
                    "ReadableContentsFormat": formats["markdown"],
                    "HumanReadable": "No results found",
                    "EntryContext": {},
                }
            return {
                "Type": entryTypes["note"],
                "Contents": response,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": tableToMarkdown(
                    "Recorded Future Alerting Rules", mapped_rules, removeNull=True
                ),
                "EntryContext": {
                    "RecordedFuture.AlertRule(val.ID === obj.id)": createContext(
                        mapped_rules
                    )
                },
            }

        def __document_formatting(self, data):
            title = data['title']

            def move_fragment_to_entity(entity, reference):
                entity['fragment'] = reference.get('fragment', '')
                return entity

            # flattens the document so that we only get documents in all entities
            documents = [doc for elem in data["entities"] for doc in elem['documents']]
            markdown_fragments = []
            data['documents'] = documents
            flat_entities = []
            for doc in documents:
                flatten_entities = [
                    move_fragment_to_entity(entity, ref) for ref in doc['references']
                    for entity in ref['entities']
                ]
                flat_entities.extend(flatten_entities)
                entity_table = tableToMarkdown(
                    "Entities for document",
                    flatten_entities,
                    removeNull=True
                )

                markdown_snippet = f"""
                    ### Title: {doc['title']}
                    URL: {doc['url']}
                    Source: {doc['source']['name']}
                    Source id: {doc['source']['id']}

                    {entity_table}

                """
                markdown_snippet = re.sub(r'\n\s+', '\n', markdown_snippet)
                markdown_fragments.append(markdown_snippet)
                doc.pop('references')

            data['flat_entities'] = flat_entities
            documents = '\n'.join(markdown_fragments)

            markdown = f"""
                ## {title}
                {documents}
            """
            markdown = re.sub(r'\n\s+', '\n', markdown)
            return {
                "Type": entryTypes["note"],
                "Contents": data,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": markdown,
                "EntryContext": {
                    "RecordedFuture.SingleAlert(val.ID === obj.id)": createContext(
                        data
                    )
                }
            }

        def __entity_formatting(self, data):
            entities = []
            evidences = {}  # name: list
            # evidence part of risk.
            entity_headers = ["name", "type", "description", "risk"]
            for entity in data["entities"]:
                entity_data = {
                    "id": entity["entity"]["id"],
                    "name": entity["entity"]["name"],
                    "type": entity["entity"]["type"],
                    "description": entity["entity"].get("description"),
                    "risk": entity["risk"].get("criticalityLabel")
                }
                entities.append(entity_data)
                if not entity["risk"].get("evidence"):
                    continue

                evidence_list = entity["risk"]["evidence"]
                evidence_mapping = {
                    "criticalityLabel": "criticality",
                    "evidenceString": "evidence"
                }
                evidence_list = [
                    rename_keys(evidence_mapping, evidence) for evidence in evidence_list
                ]

                evidences[entity["entity"]["name"]] = evidence_list

            entity_markdown = tableToMarkdown(
                "Entities for alert", entities, headers=entity_headers, removeNull=True,
            )

            evidence_headers = ["rule", "criticality", "evidence"]
            evidence_markdown = ''
            for name, evidence in evidences.items():
                evidence_markdown = evidence_markdown + tableToMarkdown(
                    f"Evidence belonging to {name}",
                    evidence,
                    headers=evidence_headers
                ) + '\n'

            markdown = f"""
                ## {data["title"]} - {data["triggered"]}

                {entity_markdown}

                {evidence_markdown}
            """
            return {
                "Type": entryTypes["note"],
                "Contents": data,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": re.sub(r'\n\s+', '\n', markdown),
                "EntryContext": {
                    "RecordedFuture.SingleAlert(val.ID === obj.id)": createContext(
                        data
                    )
                }
            }

        def get_alert_single_command(self, _id: str) -> CommandResults:
            """Command to get a single alert"""
            data = self.client.get_single_alert(_id)["data"]

            try:
                has_entity = all([entity.get('entity') for entity in data['entities']])
                if has_entity:
                    return self.__entity_formatting(data)
                return self.__document_formatting(data)
            except Exception:
                msg = 'This alert rule currently does not support a human readable format, ' \
                    'please let us know if you want it to be supported'
                return CommandResults(
                    outputs_prefix="",
                    outputs={},
                    raw_response={},
                    readable_output=msg,
                    outputs_key_field="",
                )

        def get_alerts_command(
            self, params: Dict[str, str]
        ) -> Dict[str, Any]:
            """Get Alerts Command."""
            resp = self.client.get_alerts(params)
            headers = ["Alert ID", "Rule", "Alert Title", "Triggered", "Status", "Assignee"]
            alerts_context = [
                {
                    "id": a["id"],
                    "name": a.get("title", "N/A"),
                    "triggered": prettify_time(a.get("triggered")),
                    "status": a.get("review", {}).get("status"),
                    "assignee": a.get("review", {}).get("assignee"),
                    "rule": a.get("rule", {}).get("name"),
                    "type": a.get("type"),
                    "entities": a.get("entities", []),
                }
                for a in resp.get("data", {}).get("results", [])
            ]
            if not alerts_context:
                return {
                    "Type": entryTypes["note"],
                    "Contents": {},
                    "ContentsFormat": formats["json"],
                    "ReadableContentsFormat": formats["markdown"],
                    "HumanReadable": "No results found",
                    "EntryContext": {},
                }
            alerts_table = [
                {
                    "Alert ID": ma["id"],
                    "Alert Title": ma["name"],
                    "Rule": ma["rule"],
                    "Status": ma["status"],
                    "Triggered": ma["triggered"],
                    "Assignee": ma["assignee"],
                }
                for ma in alerts_context
            ]
            return {
                "Type": entryTypes["note"],
                "Contents": resp,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": tableToMarkdown(
                    "Recorded Future Alerts",
                    alerts_table,
                    headers=headers,
                    removeNull=True,
                ),
                "EntryContext": {
                    "RecordedFuture.Alert(val.ID === obj.id)": createContext(
                        alerts_context
                    )
                },
            }

        def get_links_command(self, entity: str, entity_type: str) -> CommandResults:
            try:
                entity_data = self.client.entity_enrich(entity, entity_type, related=False, risky=False)
                links_data = entity_data.get("data", {}).pop("links")
                if "error" in links_data:
                    raise Exception(links_data["error"])
                formated_links = self.__format_links(links_data)
                scored_links = self.__soar_links(formated_links)
                markdown = self.__build_links_markdown(entity, scored_links)
                return self.__build_links_context(scored_links, markdown)
            except DemistoException as err:
                if "404" in str(err):
                    return CommandResults(
                        outputs_prefix="",
                        outputs={},
                        raw_response={},
                        readable_output="No results found.",
                        outputs_key_field="",
                    )
                else:
                    raise err

        def __format_links(self, links_data: Dict[str, Any]) -> Dict[str, List]:
            links = {}
            LINK_CATEGORIES = {
                "InternetDomainName": "Domain",
                "Hash": "Hash",
                "IpAddress": "IP address",
                "MalwareSignature": "Malware Signature",
                "MitreAttackIdentifier": "MITRE ATT&CK Identifier",
                "CyberVulnerability": "Vulnerability",
                "Organization": "Organization",
                "AttackVector": "Attack Vector",
                "Threat Actor": "Threat Actor",
                "Technology": "Technology",
                "Malware": "Malware",
                "Username": "Username",
            }
            for hit in links_data.get("hits", []):
                categories = []
                for count in hit["counts"]:
                    if count["type"]["name"] != "Insikt Group":
                        links_type = "Technical Links"
                    else:
                        links_type = "Insikt Group Research Links"
                for section in hit["sections"]:
                    lists = []
                    for sec_list in section["lists"]:
                        entities = []
                        for entity in sec_list["entities"]:
                            link = {
                                "name": entity["name"],
                                "type": entity["type"]
                            }
                            entities.append(link)
                        lists.append({
                            "entities": entities,
                            "entity_type": LINK_CATEGORIES.get(sec_list["type"]["name"], sec_list["type"]["name"])
                        })
                    categories.append({
                        "category": section["section_id"]["name"],
                        "lists": lists
                    })
                links.update({links_type: categories})
            return links

        def __soar_links(self, links_data: Dict[str, List]) -> Dict[str, List]:
            scored_links = links_data
            SOAR_TRANS = {
                "Hash": "hash",
                "Domain": "domain",
                "IP address": "ip",
                "Vulnerability": "vulnerability",
            }
            entity_score_map = {}
            for link_type_list in scored_links.values():
                for category in link_type_list:
                    for category_list in category["lists"]:
                        if category_list["entity_type"] in SOAR_TRANS:
                            entities = [entity["name"] for entity in category_list["entities"]]
                            enriched_links = self.client.entity_lookup(entities, SOAR_TRANS[category_list["entity_type"]])
                            entity_score_map.update({
                                entity["entity"]["name"]: int(entity["risk"]["score"])
                                for entity in enriched_links["data"]["results"]
                            })
                        for entity in category_list["entities"]:
                            entity["score"] = entity_score_map.get(entity["name"])
            return scored_links

        def __build_links_markdown(self, entity: str, links_data: Dict[str, List]) -> str:
            markdown = []
            if links_data:
                for link_type, type_list in links_data.items():
                    markdown.append(f'### {link_type} for: {entity}')
                    for category in type_list:
                        if category['lists']:
                            markdown.append(f'#### Category {category["category"]}\n--------')
                        for category_list in category['lists']:
                            names = []
                            for ioc in category_list['entities']:
                                score = f'**risk score: {ioc["score"]}**' if ioc["score"] else ''
                                link = {category_list['entity_type']: f'{ioc["name"]}  {score}'}
                                names.append(link)
                            markdown.append(
                                tableToMarkdown(
                                    '',
                                    names,
                                    category_list['entity_type'],
                                    removeNull=True,
                                )
                            )
            else:
                markdown.append('### Recorded Future Links **No entries**.')
            return "\n".join(markdown)

        def __build_links_context(self, links_data: Dict[str, List], markdown: str) -> CommandResults:
            return CommandResults(
                outputs_prefix=get_output_prefix('links'),
                outputs=links_data,
                readable_output=markdown,
                outputs_key_field=""
            )

        def fetch_incidents(self, rule_names_arg: Optional[str], first_fetch: str, max_fetch: Optional[int] = None) -> None:
            if rule_names_arg:
                rule_names = rule_names_arg.split(';')
            else:
                rule_names = []

            last_run = demisto.getLastRun()
            if not last_run:
                last_run = {}
            if 'time' not in last_run:
                time, _ = parse_date_range(first_fetch, date_format='%Y-%m-%dT%H:%M:%S.%fZ')
            else:
                time = last_run['time']

            current_time = datetime.strptime(time, '%Y-%m-%dT%H:%M:%S.%fZ')
            triggered_time = '[{},)'.format(datetime.strftime(current_time, '%Y-%m-%d %H:%M:%S'))
            max_time = current_time

            rule_ids = []  # type: list

            for rule in rule_names:
                rules = self.client.get_alert_rules(rule)
                if rules and 'data' in rules:
                    rule_ids += map(lambda r: r['id'], rules['data'].get('results', []))

            all_alerts = []  # type: list
            rules_get_params: Dict[str, Any] = {
                "triggered": triggered_time,
                "orderby": "triggered",
                "direction": "asc",
                "status": "no-action",
            }
            if max_fetch:
                rules_get_params["limit"] = max_fetch
            if rule_ids:
                for rule_id in rule_ids:
                    rules_get_params["alertRule"] = rule_id
                    alerts = self.client.get_alerts(rules_get_params)
                    if alerts and 'data' in alerts:
                        all_alerts += alerts['data'].get('results', [])
            else:
                alerts = self.client.get_alerts(rules_get_params)
                if alerts and 'data' in alerts:
                    all_alerts += alerts['data'].get('results', [])

            incidents = []
            update_data = []
            for alert in all_alerts:
                alert_time = datetime.strptime(alert['triggered'], '%Y-%m-%dT%H:%M:%S.%fZ')
                # The API returns also alerts that are triggered in the same time
                if alert_time > current_time:
                    # Set alerts status to pending
                    update_data.append({"id": alert['id'], "status": "pending"})
                    alert_data = self.client.get_single_alert(alert['id'])
                    if alert_data and 'data' in alert_data:
                        alert = alert_data['data']
                    incidents.append({
                        "name": "Recorded Future Alert - " + alert['title'],
                        "occurred": datetime.strftime(alert_time, "%Y-%m-%dT%H:%M:%SZ"),
                        "rawJSON": json.dumps(alert),
                    })

                    if alert_time > max_time:
                        max_time = alert_time
            if update_data:
                self.client.update_alerts(update_data)
            # Reverse the list so that they are created in the right order
            incidents.reverse()
            demisto.incidents(incidents)
            demisto.setLastRun({
                'start_time': datetime.strftime(max_time, '%Y-%m-%dT%H:%M:%S.%fZ')
            })

        def alert_set_status(self, alert_id: str, status: str):
            data = [{
                "id": alert_id,
                "status": status,
            }]
            response = self.client.update_alerts(data)
            if response.get('success'):
                # We are working only with one alert so there is one element in response list
                context_data = response.get('success')[0]
                result = CommandResults(
                    readable_output=f'## Status {status} for Alert {alert_id} was successfully set',
                    outputs_prefix=get_output_prefix('alerts'),
                    outputs=context_data,
                    outputs_key_field='id',
                )
            else:
                error_message = "; ".join(
                    error.get('reason', 'Please contact Recorded Future') for error in response.get('error')
                )
                result = CommandResults(
                    readable_output=(
                        f'## Error setting the {status} status for Alert {alert_id}.'
                        f'Reason: {error_message}'
                    ),
                )
            return result

        def alert_set_note(self, alert_id: str, note: str):
            data = [{
                "id": alert_id,
                "note": note,
            }]
            response = self.client.update_alerts(data)
            if response.get('success'):
                # We are working only with one alert so there is one element in response list
                context_data = response.get('success')[0]
                result = CommandResults(
                    readable_output=f'## Note for Alert {alert_id} was successfully set',
                    outputs_prefix=get_output_prefix('alerts'),
                    outputs=context_data,
                    outputs_key_field='id',
                )
            else:
                error_message = "; ".join(
                    error.get('reason', 'Please contact Recorded Future') for error in response.get('error')
                )
                result = CommandResults(
                    readable_output=f'## Error setting the note for Alert {alert_id}. Reason: {error_message}',
                )
            return result


    def main() -> None:
        """Main method used to run actions."""
        try:
            demisto_params = demisto.params()
            demisto_args = demisto.args()
            base_url = demisto_params.get("server_url", "").rstrip("/")
            verify_ssl = not demisto_params.get("unsecure", False)
            proxy = demisto_params.get("proxy", False)
            headers = {
                "X-RFToken": demisto_params["token"],
                "X-RF-User-Agent": f"Cortex_XSOAR/{__version__} Cortex_XSOAR_"
                f'{demisto.demistoVersion()["version"]}',
            }
            client = Client(
                base_url=base_url, verify=verify_ssl, headers=headers, proxy=proxy
            )
            command = demisto.command()
            actions = Actions(client)
            if command == "test-module":
                try:
                    client.whoami()
                    return_results("ok")
                except Exception as err:
                    message = str(err)
                    try:
                        error = json.loads(str(err).split("\n")[1])
                        if "fail" in error.get("result", {}).get("status", ""):
                            message = error.get("result", {})["message"]
                    except Exception:
                        message = (
                            "Unknown error. Please verify that the API"
                            f" URL and Token are correctly configured. RAW Error: {err}"
                        )
                    raise DemistoException(f"Failed due to - {message}")

            elif command in ["url", "ip", "domain", "file", "cve"]:
                entities = argToList(demisto_args.get(command))
                return_results(actions.lookup_command(entities, command))
            elif command == 'fetch-incidents':
                rule_names = demisto_params.get('rule_names', '').strip()
                first_fetch = demisto_params.get('first_fetch', '24 hours').strip()
                max_fetch = demisto_params.get('max_fetch', 50)
                actions.fetch_incidents(rule_names, first_fetch, max_fetch)
            elif command == "recordedfuture-threat-assessment":
                context = demisto_args.get("context")
                entities = {
                    "ip": argToList(demisto_args.get("ip")),
                    "domain": argToList(demisto_args.get("domain")),
                    "hash": argToList(demisto_args.get("file")),
                    "url": argToList(demisto_args.get("url")),
                    "vulnerability": argToList(demisto_args.get("cve")),
                    "filter": demisto_args.get("filter") == "yes"
                }
                return_results(actions.triage_command(entities, context))
            elif command == 'recordedfuture-single-alert':
                _id = demisto_args['id']
                return_results(actions.get_alert_single_command(_id))
            elif command == "recordedfuture-alert-rules":
                rule_name = demisto_args.get("rule_name", "")
                limit = demisto_args.get("limit", 10)
                return_results(actions.get_alert_rules_command(rule_name, limit))
            elif command == "recordedfuture-alerts":
                params = {
                    x: demisto_args.get(x)
                    for x in demisto_args
                    if not x == "detailed"
                }
                if params.get("rule_id", None):
                    params["alertRule"] = params.pop("rule_id")
                if params.get("offset", None):
                    params["from"] = params.pop("offset")
                if params.get("triggered_time", None):
                    date, _ = parse_date_range(
                        params.pop("triggered_time"),
                        date_format="%Y-%m-%d %H:%M:%S",
                    )
                    params["triggered"] = "[{},)".format(date)

                return_results(actions.get_alerts_command(params))
            elif command == "recordedfuture-intelligence":
                return_results(
                    actions.enrich_command(
                        demisto_args.get("entity"),
                        demisto_args.get("entity_type"),
                        demisto_args.get("fetch_related_entities") == "yes",
                        demisto_args.get("fetch_riskyCIDRips") == "yes",
                        demisto_args.get("profile", '')
                    )
                )
            elif command == "recordedfuture-links":
                return_results(
                    actions.get_links_command(
                        demisto_args.get("entity"),
                        demisto_args.get("entity_type")
                    )
                )
            elif command == "recordedfuture-alert-set-status":
                return_results(
                    actions.alert_set_status(
                        demisto_args.get("alert_id"),
                        demisto_args.get("status"),
                    )
                )
            elif command == "recordedfuture-alert-set-note":
                return_results(
                    actions.alert_set_note(
                        demisto_args.get('alert_id'),
                        demisto_args.get('note'),
                    )
                )
        except Exception as e:
            return_error(
                f"Failed to execute {demisto.command()} command. "
                f"Error: {str(e)}"
            )


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('Recorded Future v2', 'end', __line__())
  subtype: python3
  type: python
system: true
